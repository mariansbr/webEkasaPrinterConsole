unit eKasaBowa;

interface

uses
  uEkasaPrinters, DelUp;

resourcestring
  rs_VkladHot = 'Vklad hotovosti';
  rs_VybHot = 'Výber hotovosti';
  rs_FakturaC = 'Faktúra è.: ';
  rs_Uhrada = 'Úhrada ';
  rs_JednotkovaCena = 'jednotková cena (%s)';

  rs_PAYMENTTYPE_HOTOV = 'Hotovos';
  rs_PAYMENTTYPE_KARTA = 'Karta';
  rs_PAYMENTTYPE_SEK   = 'Šek';
  rs_PAYMENTTYPE_UVER  = 'Úver';

  rs_Err20H = '(32) Nesprávny poèet položiek v príkaze';
  rs_Err21H = '(33) Nesprávny poèet znakov v niektorej položke príkazu';
  rs_Err22H = '(34) Neznáme platidlo';
  rs_Err23H = '(35) Cena Celkom je nesprávna, hlási ak je zapnutý GP pre kontrolu Medzisúètu (GP1=1)';
  rs_Err24H = '(36) Cena Celkom nie je v minimálnom platidle';
  rs_Err25H = '(37) V položkách platby nie sú žiadne znaky';
  rs_Err26H = '(38) V položke Ponúknutá suma alebo Cena celkom je chyba';
  rs_Err27H = '(39) V položke Kurz je chyba';
  rs_Err28H = '(40) V položke Popis sú nepovolené znaky';
  rs_Err2AH = '(42) Preplatenie platidlom nie je povolené';
  rs_Err30H = '(48) Odpojená tlaèiareò /prerušený loop na doske FM/';
  rs_Err31H = '(49) Nesprávne heslo v príkaze vyžadujúcom heslo';
  rs_Err32H = '(50) Odmietnutie opätovnej fiskalizácie /FM už je zfiskalizovaný/';
  rs_Err33H = '(51) Odmietnutie dalšieho otvorenia dòa do 24:00h po vykonanej závierke';
  rs_Err34H = '(52) Neznámy, alebo nepovolený príkaz v danom stave FM';
  rs_Err35H = '(53) Neúspešná fiskalizácia, lebo FP nie je vložená alebo nie je èistá';
  rs_Err40H = '(64) Znak EOT v príkaze neprišiel do 3 s. od zaèiatku prenosu /time over pri príjme príkazu z PC'+#13+
              '/ resp. chyba èasového rámca /time over èakania na príkaz z PC pri blokových prenosoch/';
  rs_Err41H = '(65) Chybné BCC v príkaze od PC, /a doposia¾ aj chyba èíslovania riadku príkazu/';
  rs_Err42H = '(66) Nesprávny formát dátumu, èasu';
  rs_Err43H = '(67) Chyba èíslovania riadkov v príkazoch /rozdelenie chyby 41H/';
  rs_Err46H = '(70) Nastavovaný dátum do RTC je menší ako dátum poslednej DU z FP ak DU existuje'+#13+
              'a ak FM je zfiskalizovaný';
  rs_Err50H = '(80) Nevložená FP';
  rs_Err51H = '(81) Cudzia FP /iné SN a DKP/';
  rs_Err52H = '(82) FP s dosiahnutými limitmi';
  rs_Err53H = '(83) Èistá FP /FP bez zápisov/';
  rs_Err54H = '(84) Nezasunutá µSD karta pre kontrolný záznam (ELJ)';
  rs_Err55H = '(85) Cudzia µSD karta /iné SN a DKP/';
  rs_Err56H = '(86) Odpojený displej';
  rs_Err57H = '(87) Chybný zápis do µSD karty';
  rs_Err58H = '(88) Chybný zápis do FP';
  rs_Err59H = '(89) SD karta je zapísaná do max. kapacity';
  rs_Err60H = '(96) Chyba parametra v príkaze';
  rs_Err61H = '(97) Odmietnutie príkazu otvorenia úètenky z dôvodu prechodu 24:00h bez závierky';
  rs_Err62H = '(98) Odmietnutie iného príkazu ako potvrdenie o servisnej prehliadke a Get variable';
  rs_Err63H = '(99) Odmietnutie iného príkazu ako potvrdenie o zostatkoch DU vo FP a Get variable';
  rs_Err64H = '(100) Odmietnutie príkazu zmeò heslo z dôvodu, že HW prepínaè je v polohe nedovo¾ujúcej'+#13+
              'meni heslo tzn. v tejto polohe platí default heslo.';
  rs_Err65H = '(101) Nepovolené použitie DU. V danom dni je otvorená druhá smena';
  rs_Err66H = '(102) Odmietnutie príkazu vykonania servisnej prehliadky, nako¾ko doposia¾ nebola oznamovaná'+#13+
              'informácia o tejto potrebe.';
  rs_Err67H = '(103) Odmietnutie príkazu z dôvodu, že SPI nebola identifikovaná, tzn., že došlo k HW závade'+#13+
              'na SPI odstránitelnej len servisným zásahom. Zariadenie je v stave S120. Povolený'+#13+
              'príkaz GET variable.';
  rs_Err68H = '(104) Odmietnutie príkazu z dôvodu, že nastala závada pri zápise dát –back up údajov do SPI,'+#13+
              'tzn., že došlo k HW závade na SPI., ktorú je možné odstráni výmazom back up údajov'+#13+
              'a následným zápisom aktuálnych back up údajov. Zariadenie je v stave S121.'+#13+
              'Povolený príkaz GET variable a príkaz obnovy SPI.=kode 78H.';
  rs_Err69H = '(105) Odmietnutie príkazu z dôvodu, že nastala závada pri zápise dát do MMC. FM bude v stave S122.'+#13+
              'Povolené príkazy sú Get variable, Get back up, Test HW.';
  rs_Err6AH = '(106) Odmietnutie príkazu z dôvodu, že nastala závada na RTC /RTC dáva nereálne dátumy a èasy/.'+#13+
              'FM bude v stave S123. Povolené príkazy sú Get variable, Get back up, Test HW.';
  rs_Err6BH = '(107) Odmietnutie príkazu z dôvodu, že nastala závada na FP poèas zápisu dát. FM bude'+#13+
              'v stave S124. Povolené príkazy sú Get variable.';
  rs_Err6CH = '(108) Odmietnutie príkazu init FM z dôvodu, že síce SN a DKP, MMC a SN, FP a SN,'+#13+
              'DKP FM sú zhodné, ale dátum a èíslo poslednej závierky z FP a dátum a èíslo'+#13+
              'poslednej závierky z ELJ nie sú zhodné.';
  rs_Err6DH = '(109) Chyba overenia CRC ELJ. CRC z ELJ nie je totožné s CRC z ELJ uložené vo FP.';
  rs_Err81H = '(129) Ponúknutá suma nie je násobkom minimálneho platidla hlavnej meny(mena 16 alebo'+#13+
              'platidlo s kurzom 0) ide o chybu parametra v príkaze.';
  rs_Err82H = '(130) Minimálne platidlo akumulátorov 1..16 pri zadefinovanom kurze 0 (èiže hlavná mena je'+#13+
              'platidlo 16) nie je násobkom najmenšej možnej jednotky èiže vmp.(virtuálne minimálne'+#13+
              'platidlo) toto nastane iba ak virtuál min. teraz natvrdo=0.01 by nebolo celistvým'+#13+
              'násobkom min. platidiel, tak to nastane a vysvieti sa chyba parametra.';
  rs_Err83H = '(131) Ponúknutá suma vedlajších mien nie je násobkom minimálneho platidla týchto mien.'+#13+
              'Ide o platidlo zahr. mena, ked by ponúknutá suma nebola celistvým násobkom min.'+#13+
              'platidla danej zahr. meny, chyba parametra.';
  rs_Err84H = '(132) Virtuálne minimálne platidlo, alebo minimálne platidlo je nulové. Chyba nastavenia min.'+#13+
              'platidla.';
  rs_Err85H = '(133) Preplatenie nie je dovolené. Ponúknutá suma je väcšia ako suma na doplatenie.'+#13+
              'Ide o nedovolene preplatenie.';
  //Chyby komunikacie so SFS
  rs_SFS_Err_2 = '(-2) Zlé vstupné hodnoty.'; //-2
  rs_SFS_Err_8 = '(-8) Táto verzia integraèného rozhrania už nie je naïalej podporovaná.'; //-8
  rs_SFS_Err_10 = '(-10) Chyba v podpise dátovej správy.'; //-10
  rs_SFS_Err_12 = '(-12) Nesprávny formát certifikátu.'; //-12
  rs_SFS_Err_13 = '(-13) Použitý certifikát nie je platný.'; //-13
  rs_SFS_Err_100 = '(-100) Nesprávna hodnota PKP.'; //-100
  rs_SFS_Err_101 = '(-101) DIÈ v dátovej správe sa nezhoduje s DIÈ z certifikátu.'; //-101
  rs_SFS_Err_102 = '(-102) Kód ORP v dátovej správe sa nezhoduje s kódom ORP z certifikátu.'; //-102
  rs_SFS_Err_103 = '(-103) Dátum a èas vyhotovenia dokladu je neskorší ako dátum a èas spracovania.'; //-103
  rs_SFS_Err_104 = '(-104) Dátum a èas vytvorenia dokladu je neskorší ako dátum a èas spracovania.'; //-104
  rs_SFS_Err_105 = '(-105) Dátum a èas vytvorenia dokladu je skorší ako dátum a èas spracovania.'; //-105
  rs_SFS_Err_106 = '(-106) Dátum a èas vyhotovenia dokladu je skorší ako dátum a èas spustenia systému.'; //-106
  rs_SFS_Err_107 = '(-107) Dátum a èas vytvorenia dokladu je skorší ako dátum a èas spustenia systému.'; //-107
  rs_SFS_Err_108 = '(-108) Dátum a èas vytvorenia údajov o polohe je neskorší ako dátum a èas spracovania.'; //-108
  rs_SFS_Err_109 = '(-109) Dátum a èas vytvorenia údajov o polohe je skorší ako dátum a èas spracovania.'; //-109
  rs_SFS_Err_110 = '(-110) Dátum a èas vytvorenia údajov o polohe je skorší ako dátum a èas spustenia systému.'; //-110
  rs_SFS_Err_111 = '(-111) Nesprávna hodnota OKP.'; //-111
  rs_SFS_Err_112 = '(-112) Èíslo faktúry musí by vyplnené pre typ dokladu: Úhrada faktúry.'; //-112
  rs_SFS_Err_113 = '(-113) Rozpis DPH nesmie byt vyplnené pre typ dokladu: Úhrada faktúry, Vklad, Výber.'; //-113
  rs_SFS_Err_114 = '(-114) Typ dokladu: Úhrada faktúry, Vklad, Výber nesmie obsahova položky.'; //-114
  rs_SFS_Err_115 = '(-115) Èíslo faktúry nesmie by vyplnené pre typ dokladu: Platný doklad, Neplatný doklad, Vklad, Výber.'; //-115
  rs_SFS_Err_116 = '(-116) Typ dokladu: Platný doklad, Neplatný doklad musí obsahova položky.'; //-116
  rs_SFS_Err_117 = '(-117) Pre typ položky: Vrátená, Opravná musí by vyplnené referenèné èíslo dokladu, ku ktorému sa vrátenie, oprava vzahuje.'; //-117
  rs_SFS_Err_118 = '(-118) Pre typ položky: Kladná, Vrátené obaly, Z¾ava nesmie by vyplnené referenèné èíslo dokladu.'; //-118
  rs_SFS_Err_119 = '(-119) Rozpis DPH musí by vyplnené pre typ dokladu: Platný doklad, Neplatný doklad.'; //-119
  rs_SFS_Err_120 = '(-120) Suma dane základnej sadzby a Základ základnej sadzby dane musia by vyplnené obe, alebo ani jedno.'; //-120
  rs_SFS_Err_121 = '(-121) Suma dane zníženej sadzby a Základ zníženej sadzby dane musia by vyplnené obe, alebo ani jedno.'; //-121
  rs_SFS_Err_122 = '(-122) ID kupujúceho a Typ ID kupujúceho musia by vyplnené obe, alebo ani jedno.'; //-122
  rs_SFS_Err_123 = '(-123) ID kupujúceho a Typ ID kupujúceho nesmú by vyplnené pre typ dokladu: Neplatný doklad, Vklad, Výber.'; //-123
  rs_SFS_Err_124 = '(-124) Èíslo paragónu je povinné v prípade evidovania paragónu.'; //-124
  rs_SFS_Err_125 = '(-125) Èíslo paragónu môže by vyplnené iba v prípade evidovania paragónu.'; //-125
  rs_SFS_Err_126 = '(-126) Paragón nie je možné zaevidova pre typ dokladu: Neplatný doklad, Vklad, Výber.'; //-126
  rs_SFS_Err_127 = '(-127) Typ položky: Kladná nesmie ma zápornú cenu.'; //-127
  rs_SFS_Err_128 = '(-128) Typ položky: Vrátené obaly, Vrátená, Z¾ava, Odpoèítaná záloha, Výmena poukazu nesmie ma kladnú cenu.'; //-128
  rs_SFS_Err_129 = '(-129) ID predávajúceho a Typ ID predávajúceho musia by vyplnené obe, alebo ani jedno.'; //-129
  rs_SFS_Err_130 = '(-130) Pre priradenie dane: 20, 10 nesmie by vyplnená Slovná informácia.'; //-130
  rs_SFS_Err_131 = '(-131) Pre typ položky: Kladná, Vrátené obaly, Vrátená, Z¾ava, Odpoèítaná záloha nesmie by vyplnené Èíslo jednoúèelového poukazu.'; //-131
  rs_SFS_Err_132 = '(-132) Nesprávna èasová zóna.'; //-132
  //Chyby komunikacie so SFS end
  rs_ErrD0H = '(208) Súbor sa nenašiel';
  rs_ErrD1H = '(209) Chyba èítania alebo zapisovania do súboru';
  rs_ErrFDH = '(253) Chyba PPEKK (pod¾a 1.1 zoznamu špecifických chýb PPEKK)';
  rs_ErrFEH = '(254) Chyba databázy';
  //Zoznam špecifických chýb PPEKK
  rs_PPEKK_Err_1 = 'už je vytvorená inštancia s inou databázou';
  rs_PPEKK_Err_2 = 'nepodarilo sa inicializova databázu';
  rs_PPEKK_Err_3 = 'nepodarilo sa inicializova CHDÚ';
  rs_PPEKK_Err_4 = 'nepodarilo sa inicializova tlaèiareò';
  rs_PPEKK_Err_5 = 'pokus o spracovanie nepodporovanej správy';
  rs_PPEKK_Err_6 = 'komunikácia s PPEKK pre iné UUID (pokus o hacknutie systému)';
  rs_PPEKK_Err_7 = 'nedá sa pripoji k CHDÚ';
  rs_PPEKK_Err_8 = 'v CHDÚ sa nenašli dáta';
  rs_PPEKK_Err_9 = 'v CHDÚ sú údaje v zlom tvare';
  rs_PPEKK_Err_10 = 'CHDÚ nie je konfigurované';
  rs_PPEKK_Err_11 = 'chyba pri práci s databázou';
  rs_PPEKK_Err_12 = 'nedá sa šifrova práca s databázou';
  rs_PPEKK_Err_13 = 'chyba pri generovaní tlaèe';
  rs_PPEKK_Err_14 = 'chyba dåžky parametra';
  rs_PPEKK_Err_15 = 'nastavovací parameter neexistuje, alebo je jeho hodnota zlá';
  rs_PPEKK_Err_16 = 'nepodporovaná sekvencia';
  rs_PPEKK_Err_17 = 'neplatná sadzba DPH';
  rs_PPEKK_Err_18 = 'zle vypoèítané hodnoty DPH pre doklad';
  rs_PPEKK_Err_19 = 'chyba v komunikaènom module na SFS';
  rs_PPEKK_Err_20 = 'SFS vrátilo chybu odoslanej správy';
  rs_PPEKK_Err_21 = 'chyba pri práci s CFG';
  rs_PPEKK_Err_22 = 'nie sú nahraté autentifikaèné údaje';
  rs_PPEKK_Err_23 = 'tlaèiareò nie je pripravená';
  rs_PPEKK_Err_24 = 'interná chyba pri spracovaní aplikácie';
  rs_PPEKK_Err_25 = 'zle zadané množstvo';
  rs_PPEKK_Err_26 = 'zle zadaná jednotková cena';
  rs_PPEKK_Err_27 = 'zle zadaná cena za položku';
  rs_PPEKK_Err_28 = 'zlé identifikaèné údaje';
  rs_PPEKK_Err_29 = 'zlé autentifikaèné heslo';
  rs_PPEKK_Err_30 = 'je viac rovnakých kategórií DPH pre jednu sadzbu';
  rs_PPEKK_Err_31 = 'údaje na CHDÚ a PPEKK sú rôzne';
  rs_PPEKK_Err_32 = 'zlý formát autentifikaèných údajov';
  rs_PPEKK_Err_33 = 'neplatný certifikát autentifikaèných údajov';
  rs_PPEKK_Err_34 = 'DIÈ, DKP nesedia pre toto CHDÚ';
  rs_PPEKK_Err_35 = 'zlý formát identifikaèných údajov';
  rs_PPEKK_Err_36 = 'DIÈ, DKP nesedia pre toto CHDÚ';
  rs_PPEKK_Err_37 = 'chyba pri párovaní opravovanej a pokazenej transackcie';
  rs_PPEKK_Err_38 = 'zlé použitie JÚP';
  rs_PPEKK_Err_39 = 'nepodarilo sa vygenerova swid';
  rs_PPEKK_Err_40 = 'chýbajúca licencia';
  rs_PPEKK_Err_41 = 'CHDÚ bolo odpojené poèas normálneho režimu komunikácie';
  rs_PPEKK_Err_42 = 'pokus o synchronizáciu medzi PPEKK a CHDÚ, keï to nie je možné';
  rs_PPEKK_Err_43 = 'chyba komunikácie s CHDÚ';
  rs_PPEKK_Err_44 = 'CHDÚ prekroèilo timeout na vykonanie operácie';
  rs_PPEKK_Err_45 = 'chyba upgrade CHDÚ';
  rs_PPEKK_Err_46 = 'PPEKK nemá niè na opravenie, hoci žiadate o opravný doklad';
  rs_PPEKK_Err_47 = 'používa sa dátum vytvorenia dokladu skorší ako je povolené';
  rs_PPEKK_Err_48 = 'parameter k oprave zápisu je nesprávny';
  rs_PPEKK_Err_49 = 'zlý inicializaèný string';
  rs_PPEKK_Err_50 = 'je vyžadovaná aspoò jedna položka';
  rs_PPEKK_Err_51 = 'chyba èasového pásma';
  rs_PPEKK_Err_52 = 'niektorý z parametrov príkazu je nesprávny';
  rs_PPEKK_Err_53 = 'chyba ukladania config súboru, bol vykonaný rollback';

  rs_S0     = 'Systémové nastavenia';
  rs_S1     = 'Otvorenie predajného dòa';
  rs_S2     = 'Predaj / telo úètenky';
  rs_S3     = 'Vykonanie platby';
  rs_S4     = 'Ukonèenie úètenky';
  rs_S10    = 'Interný doklad';
  rs_S20    = 'Vklad / výber';
  rs_S70    = '';
  rs_S100   = 'HW závada';
  rs_S101   = 'Cudzia fiškálna pamä';
  rs_S102   = 'Cudzia pamä µSD';
  rs_S103   = 'Limit fiškálné pamäte';
  rs_S104   = 'Nevložená fiškálna pamä';
  rs_S105   = 'Èistá fiškálna pamä';
  rs_S106   = 'Odpojená tlaèiareò';
  rs_S107   = 'Odpojený displej';
  rs_S108   = 'Nezasunutá µSD';
  rs_S109   = 'Plná µSD';
  rs_S113   = 'Hlásenie SERVISNÁ PREHLIADKA';
  rs_S114   = 'Hlásenie LIMIT DU pod 50 zápisov';

const
  rs_connection_error = '{"errorCode":500,"error":"Nepodarilo sa spojenie s Bowa. Skontrolujte ju!"}';

  C_ESC_CHAR = '~';

  C_VAR_SEP = ';';    // Oddelovac poli v retezci vracenem getVariable
  C_VAR_12  = '12';   // TAX data A ~ TAX data E local
  C_VAR_E4  = 'E41';  // Pouzivane typy platidel
  C_VAR_E7  = 'E7';   // PAYMENTTYPE data 1(E71) ~ PAYMENTTYPE data G (E7G) local
  C_VAR_F6  = 'F61';  // Flag S90 – „vynútená“ DU
  C_VAR_B51 = 'B51';  // Vyèítanie poslednej chyby PPEKK a poslednej chyby databázy FM

  // Danove hladiny
  C_VAT_A = 'A';
  C_VAT_B = 'B';
  C_VAT_C = 'C';
  C_VAT_D = 'D';
  C_VAT_E = 'E';
  C_VAT_F = 'F';

  C_LEN_PAYMENT       = 10;
  C_LEN_DISCOUNT      = 18;
  C_LEN_DEPOSITE      = 20; // depositeInDrawer
  C_LEN_ANNOUCEMENTNF = 39;
  C_LEN_ANNOUCEMENT   = 40;
  C_LEN_5             = 5;
  C_LEN_10            = 10;
  C_LEN_50            = 50; // setClientID, setSellerID

  C_DEVICENUMBER = 1;
  C_PASSWORD = 'Pegas006';
  C_SALEMODE_TEST = 0;
  C_SALEMODE_FISKAL = 1;
  FM_INTERFACE_LINK = '127.0.0.1:30000';

  C_DEPOSITEINDRAWER_VKLAD = 0;
  C_DEPOSITEINDRAWER_VYBER = 1;

  C_ITEMDISCOUNT_SLEVAHOD = 0;      // hodnotová z¾ava
  C_ITEMDISCOUNT_PRIRAZKAHOD = 1;   // hodnotová prirážka

  C_SALETYPE_0 = 0;  // Maloobchod (ceny s DPH)
  C_SALETYPE_1 = 1;  // Ve¾koobchod (ceny bez DPH)
  C_SALETYPE_2 = 2;  // Interný doklad (bez orezu)
  C_SALETYPE_3 = 3;  // Interný doklad (binárny)
  C_SALETYPE_5 = 5;  // Vklad/vyber
  C_SALETYPE_6 = 6;  // Interný doklad
  C_SALETYPE_9 = 9;  // Faktúra

  C_TYPPRENOSU_ROW = 0;
  C_TYPPRENOSU_BLOCK = 1;

  C_PARAGONTYPE_PLUS = 0; // kladny blocek
  C_PARAGONTYPE_MINUS = 1; // zaporny blocek

  C_TYPREKAP_SHORT = 0;  // zkracena rekapitulace
  C_TYPREKAP_ALL = 1;  // plna rekapitulace

  C_GRAPHICSHDR_NO = 0; // bez graficke hlavicky

  C_PAYMENTTYPE_KARTA = 1;
  C_PAYMENTTYPE_SEK   = 2;
  C_PAYMENTTYPE_STRAV = 3;
  C_PAYMENTTYPE_ZAHR  = 4;
  C_PAYMENTTYPE_UVER  = 5;    // USR5
  C_PAYMENTTYPE_USR6  = 6;
  C_PAYMENTTYPE_USR7  = 7;
  C_PAYMENTTYPE_USR8  = 8;
  C_PAYMENTTYPE_USR9  = 9;
  C_PAYMENTTYPE_USR10 = 10;
  C_PAYMENTTYPE_USR11 = 11;
  C_PAYMENTTYPE_USR12 = 12;
  C_PAYMENTTYPE_USR13 = 13;
  C_PAYMENTTYPE_USR14 = 14;
  C_PAYMENTTYPE_USR15 = 15;
  C_PAYMENTTYPE_HOTOV = 16;

type
  TStavBowa = record
    PKod: string;
    StavSDC : integer;
    StavPRN : integer;
    StavPC : integer;
    CRiadku : integer;
    StavS : integer;
    StavF : integer;
    VerziaF : integer;
  end;

  TDUBowa = record
    PKod: string;
    CisloDU : integer;
    DatCasDU : string;
    StavDU : integer;
    DatCasDS : string;
  end;

  TCHDUBowa = record
    chdu: string;
    ppekk: string;
    lastTransactionNumber: string;
    storageSize: string;
    sectorSize: string;
  end;

  TSFSBowa = record
    numberUnsentMessages: string;
    validitySignatureCertificate: string;
  end;

  TVats = array[1..5] of currency;

  procedure internalInit();
  procedure internalClose();

  function eKasaBowaInit: boolean;
  function eKasaBowaWork(action: TEkasaActions): string;

  function internalReadVariable(variableCode: string; onlyVariable: boolean = false): string;
  function internalReadStavFM: TStavBowa;
  function internalReadStavDU: TDUBowa;
  function internalReadStavCHDU(): TCHDUBowa;
  function internalReadStavSFS(): TSFSBowa;
  procedure internalReadVats();

  function errorStr(errCode: integer): string;
  function sfsError(errCode: integer): boolean;
  function sfsErrorStr(errCode: integer): string;
  function ppekkErrorStr(errCode: integer): string;

implementation

uses
  Classes, SysUtils, StrUtils, Windows, uSettings, uCommon, payPackageUtils,
  superObject, uEkasaHelper;

var
  vats: TVats;
  bowaOpen: boolean = false;
  cashRoundSupport: integer = -1; //-1 nebolo zistene, 0 nepodporovane, 1 podporovane
  C_LEN_LINE: integer = 0;
  dllHandle: THandle;

  _openFM: function(pszPortName: PAnsiChar): integer; cdecl;
  _closeFM: procedure(); cdecl;
  // Paragon begin, paragon end, selling day begin
  _paragonBegin: function(deviceNumber, rowNumber, saleType, communicationType, paragonType, recapitulationType, graphicHeader: integer): integer; cdecl;
  _paragonEnd: function(deviceNumber, rowNumber, graphicHeader: integer): integer; cdecl;
  _repeatParagon: function(deviceNumber: integer):integer; cdecl;
  _destroyParagon: function(deviceNumber, rowNumber: integer; description: PAnsiChar): integer; cdecl;
  _sellingDayBegin: function(deviceNumber, saleMode: integer): integer; cdecl;
  // Payment
  _payment_int: function(deviceNumber, rowNumber, paymentNumber: integer; total_2, payedAmount_2, exchangeRate_2: integer; description: PAnsiChar):integer; cdecl;
  // ItemSale
  _setPreline: function(deviceNumber: integer; description: PAnsiChar): integer; cdecl;
  _setPostline: function(deviceNumber: integer; description: PAnsiChar): integer; cdecl;
  _itemSale_int: function(deviceNumber, rowNumber: integer; commodityName: PAnsiChar; totalPrice_2: integer; vat: PAnsiChar; amount_3, unitPrice_4: integer; unit1: PAnsiChar): integer; cdecl;
  _itemReturn_int: function(deviceNumber, rowNumber: integer; commodityName: PAnsiChar; totalPrice_2: integer; vat: PAnsiChar; amount_3, unitPrice_4: integer; unit1, receiptNumber: PAnsiChar): integer; cdecl;
  _itemNegative_int: function(deviceNumber, rowNumber: integer; commodityName: PAnsiChar; totalPrice_2: integer; vat: PAnsiChar; amount_3, unitPrice_4: integer; unit1: PAnsiChar): integer; cdecl;
  _itemDiscount_int: function(deviceNumber, rowNumber: integer; description: PAnsiChar; operationType, discountValue_2: integer; vat: PAnsiChar): integer; cdecl;

  _getVariable: function(deviceNumber: integer; variableCode, result: PAnsiChar; resultLength: integer): integer; cdecl;
  _setParameter: function(deviceNumber: integer; password: PAnsiChar; paramNumber, paramValue: integer): integer; cdecl;
  _setDateTime: function(deviceNumber:integer; date: PAnsiChar):integer; cdecl;
  _printAnnouncement: function(deviceNumber, rowNumber: integer; text: PAnsiChar):integer; cdecl;
  _printAnnouncementNF: function(deviceNumber, rowNumber: integer; text: PAnsiChar):integer; cdecl;
  _depositeInDrawer_int: function(deviceNumber, rowNumber: Integer; description: PAnsiChar; operationType, amount_2, paymentNumber: integer): integer; cdecl;
  _confirmNote: function(deviceNumber: Integer): integer; cdecl;

  // PegasOnline v1.1
  _setClientID: function(deviceNumber: integer; number: PAnsiChar; type1: integer): integer; cdecl;
  _printIssuedParagon: function(deviceNumber, orderNumber: integer; dateTime: PAnsiChar): integer; cdecl;
  _setInvoiceNumber: function(deviceNumber: integer; invoiceNumber: PAnsiChar): integer; cdecl;
  _redeemVoucher: function(deviceNumber: integer; title: PAnsiChar; amount: double; vat: PAnsiChar; price: double; voucherNumber: PAnsiChar): integer; cdecl;
  _redeemVoucher_str: function(deviceNumber: integer; title: PAnsiChar; amount: PAnsiChar; vat: PAnsiChar; price: PAnsiChar; voucherNumber: PAnsiChar): integer; cdecl;
  _getParagonIDs_str: function(deviceNumber: integer; inputType, input, result: PAnsiChar; resultLength: integer): integer; cdecl;
  _getParagonIDs_ResultObject: function(deviceNumber: integer; inputType, input, resultObject: PAnsiChar): integer; cdecl;
  _getParagonIDs_str_ResultObject: function(deviceNumber: integer; inputType, input, resultObject: PAnsiChar): integer; cdecl;
  _setTransactionID: function(deviceNumber: integer; internalCode: PAnsiChar): integer; cdecl;
  _setLocationGPS: function(deviceNumber: integer; vertX, vertY: double): integer; cdecl;
  _setLocationAddress: function(deviceNumber: integer; municipality, street, number, subNumber, zip: PAnsiChar): integer; cdecl;
  _setLocationOther: function(deviceNumber: integer; description: PAnsiChar): integer; cdecl;
  _printUnsentSFSpackets: function(deviceNumber: integer): integer; cdecl;
  _sendUnsentSFSpackets: function(deviceNumber: integer): integer; cdecl;
  _printReport_str: function(deviceNumber: integer; reportType: PAnsiChar; reportNumber: integer): integer; cdecl;
  _Popis0DPH_str: function(deviceNumber: integer; type1: PAnsiChar): integer; cdecl;
  _printJournalStructU: function(deviceNumber: integer; paragonSn: PAnsiChar): integer; cdecl;
  _setRawLogginOn: procedure(fileName: PAnsiChar); cdecl;
  _seRawLogginOff: procedure(); cdecl;
  _printDisplay: function(deviceNumber, displayType: integer; escSequence, text: PAnsiChar): integer; cdecl;
  _clearDisplay: function(deviceNumber, displayType: integer; escSequence: PAnsiChar): integer; cdecl;
  _setEscapeSequence: function(deviceNumber: integer; sequence: PAnsiChar): integer; cdecl;
  _setEmail: function(deviceNumber: integer; email: PAnsiChar): integer; cdecl;
  _setSMTP: function(deviceNumber: integer; type1: PAnsiChar; ipAddress: PAnsiChar; port: integer; localDir: PAnsiChar): integer; cdecl;
  _opravaDokladu: function(deviceNumber: integer; errCode: PAnsiChar): integer; cdecl;
  _setSellerID_str: function(deviceNumber: integer; number, type1: PAnsiChar): integer; cdecl;
  _synchronizationToPPEKK: function(deviceNumber: integer): integer; cdecl;
  _setLicense: function(deviceNumber: integer; licenseCode: PAnsiChar): integer; cdecl;
  _getLastTransactionPackets: function(deviceNumber, transactionCount: integer): integer; cdecl;

// Prepisane funkcie DLL s osetrenim dlzky retazcov
function openFM(sPortName: string): integer;
begin
  result := _openFM(PAnsiChar(StrToAStr(sPortName)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_openFM(%s) = %d',[sPortName,result]));
end;

procedure closeFM();
begin
  _closeFM();
  if fSettings.B['ekasa.withLog'] then
    addLog('_closeFM()');
end;

function paragonBegin(rowNumber, saleType, communicationType, paragonType, recapitulationType, graphicHeader:integer): integer;
begin
  result := _paragonBegin(C_DEVICENUMBER, rowNumber, saleType, communicationType, paragonType, recapitulationType, graphicHeader);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_paragonBegin(%d,%d,%d,%d,%d,%d,%d) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   saleType,
                   communicationType,
                   paragonType,
                   recapitulationType,
                   graphicHeader,
                   result]));
end;

function paragonEnd(rowNumber, graphicHeader:integer): integer;
begin
  result := _paragonEnd(C_DEVICENUMBER, rowNumber, graphicHeader);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_paragonEnd(%d,%d,%d) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   graphicHeader,
                   result]));
end;

function repeatParagon(): integer;
begin
  result:= _repeatParagon(C_DEVICENUMBER);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_repeatParagon(%d) = %d',
                  [C_DEVICENUMBER,
                   result]));
end;

function destroyParagon(rowNumber: integer; description: string): integer;
begin
  description := LeftStr(description, C_LEN_LINE);
  result := _destroyParagon(C_DEVICENUMBER, rowNumber, PAnsiChar(StrToAStr(description)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_destroyParagon(%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   description,
                   result]));
end;

function setInvoiceNumber(invoiceNumber: string): integer;
begin
  result := _setInvoiceNumber(C_DEVICENUMBER, PAnsiChar(StrToAStr(invoiceNumber)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setInvoiceNumber(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   invoiceNumber,
                   result]));
end;

function redeemVoucher(title: string; amount: double; vat: string; price: double; voucherNumber: string): integer;
var
  decSep: Char;
begin
  decSep := FormatSettings.DecimalSeparator;
  try
    FormatSettings.DecimalSeparator := '.';
    title := LeftStr(title, C_LEN_LINE);
    vat := LeftStr(vat, 1);
    voucherNumber := LeftStr(voucherNumber, C_LEN_50);
    result := _redeemVoucher( C_DEVICENUMBER,
                              PAnsiChar(StrToAStr(title)),
                              Zaok(amount, 2, 0),
                              PAnsiChar(StrToAStr(vat)),
                              Abs(Zaok(price, 2, 0)),
                              PAnsiChar(StrToAStr(voucherNumber)) );
  finally
    FormatSettings.DecimalSeparator := decSep;
  end;
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_redeemVoucher(%d,%s,%d,%s,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   title,
                   Zaok(amount, 2, 0),
                   vat,
                   Abs(Zaok(price, 2, 0)),
                   voucherNumber,
                   result]));
end;

function setClientID(number: string; type1: integer): integer;
begin
  number := LeftStr(number, C_LEN_50);
//typ:1 - ICO, 2 - DIC, 3 - ICDPH, 4 - INE
  result := _setClientID(C_DEVICENUMBER, PAnsiChar(StrToAStr(number)), type1);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setClientID(%d,%s,%d) = %d',
                  [C_DEVICENUMBER,
                   number,
                   type1,
                   result]));
end;

function payment_int(rowNumber, paymentNumber: integer; total_2, payedAmount_2, exchangeRate_2: integer; description: string): integer;
begin
  description:= LeftStr(description, C_LEN_PAYMENT);
  result:= _payment_int( C_DEVICENUMBER,
                         rowNumber,
                         paymentNumber,
                         total_2,
                         payedAmount_2,
                         exchangeRate_2,
                         PAnsiChar(StrToAStr(description)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_payment_int(%d,%d,%d,%d,%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   paymentNumber,
                   total_2,
                   payedAmount_2,
                   exchangeRate_2,
                   description,
                   result]));
end;

function sendUnsentSFSpackets(): integer;
begin
  result := _sendUnsentSFSpackets(C_DEVICENUMBER);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_sendUnsentSFSpackets(%d) = %d',
                  [C_DEVICENUMBER,
                   result]));
end;

function printUnsentSFSpackets(): integer;
begin
  result := _printUnsentSFSpackets(C_DEVICENUMBER);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printUnsentSFSpackets(%d) = %d',
                  [C_DEVICENUMBER,
                   result]));
end;

function getVariable(variableCode: string; var sresult: string): integer;
const
  C_LEN_BUFF = 1024;
var
  Buff: array [1..C_LEN_BUFF] of AnsiChar;
begin
  sresult := '';

  result := _getVariable(C_DEVICENUMBER, PAnsiChar(StrToAStr(variableCode)), @Buff, C_LEN_BUFF);
  Sleep(5);
  if result = 0 then
    sresult := AStrToStr(StrPas(PAnsiChar(@Buff)))
  else
    sresult := '';
  if fSettings.B['ekasa.withLog'] then begin
    addLog(Format('_getVariable(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   variableCode,
                   result]));
    addLog(Format('_getVariable.sresult = %s',[sresult]));
  end;
end;

function setParameter(paramNumber, paramValue: integer): integer;
begin
  result := _setParameter(C_DEVICENUMBER, PAnsiChar(StrToAStr(C_PASSWORD)), paramNumber, paramValue);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setParameter(%d,%s,%d,%d) = %d',
                  [C_DEVICENUMBER,
                   C_PASSWORD,
                   paramNumber,
                   paramValue,
                   result]));

end;

function setDateTime(date_s: string): integer;
begin
  result := _setDateTime(C_DEVICENUMBER, PAnsiChar(StrToAStr(date_s)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setDateTime(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   date_s,
                   result]));
end;

function confirmNote(): integer;
begin
  result := _confirmNote(C_DEVICENUMBER);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_confirmNote(%d) = %d',
                  [C_DEVICENUMBER,
                   result]));
end;

function sellingDayBegin(saleMode: integer): integer;
begin
  result := _sellingDayBegin(C_DEVICENUMBER, saleMode);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_sellingDayBegin(%d,%d) = %d',
                  [C_DEVICENUMBER,
                   saleMode,
                   result]));
end;

function depositeInDrawer_int(rowNumber: Integer; description: string; operationType, amount_2, paymentNumber: integer): integer;
begin
  description := LeftStr(description, C_LEN_DEPOSITE);
  result := _depositeInDrawer_int( C_DEVICENUMBER,
                                   rowNumber,
                                   PAnsiChar(StrToAStr(description)),
                                   operationType,
                                   amount_2,
                                   paymentNumber );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_depositeInDrawer_int(%d,%d,%s,%d,%d,%d) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   description,
                   operationType,
                   amount_2,
                   paymentNumber,
                   result]));
end;

function printAnnouncement(rowNumber: integer; text: string): integer;
begin
  text := LeftStr(text, C_LEN_ANNOUCEMENT);
  result := _printAnnouncement(C_DEVICENUMBER, rowNumber, PAnsiChar(StrToAStr(text)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printAnnouncement(%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   text,
                   result]));
end;

function printAnnouncementNF(rowNumber: integer; text: string): integer;
begin
  text := LeftStr(text, C_LEN_ANNOUCEMENTNF);
  result := _printAnnouncementNF(C_DEVICENUMBER, rowNumber, PAnsiChar(StrToAStr(text)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printAnnouncementNF(%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   text,
                   result]));
end;

function setPreline(description: string): integer;
begin
  description := LeftStr(description, C_LEN_LINE);
  result := _setPreline(C_DEVICENUMBER, PAnsiChar(StrToAStr(description)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setPreline(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   description,
                   result]));
end;

function setPostline(description: string): integer;
begin
  description := LeftStr(description, C_LEN_LINE);
  result := _setPostline(C_DEVICENUMBER, PAnsiChar(StrToAStr(description)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setPostline(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   description,
                   result]));
end;

function itemSale_int(rowNumber: integer; commodityName: string; totalPrice_2: integer; vat: string; amount_3, unitPrice_4: integer; unit1: string): integer;
begin
  commodityName := LeftStr(commodityName + StringOfChar(' ', C_LEN_LINE), C_LEN_LINE);
  vat := LeftStr(vat, 1);
  unit1 := LeftStr(unit1, 3);
  result := _itemSale_int( C_DEVICENUMBER,
                           rowNumber,
                           PAnsiChar(StrToAStr(commodityName)),
                           totalPrice_2,
                           PAnsiChar(StrToAStr(vat)),
                           amount_3,
                           unitPrice_4,
                           PAnsiChar(StrToAStr(unit1)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_itemSale_int(%d,%d,%s,%d,%s,%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   commodityName,
                   totalPrice_2,
                   vat,
                   amount_3,
                   unitPrice_4,
                   unit1,
                   result]));
end;

function itemReturn_int(rowNumber: integer; commodityName: string; totalPrice_2: integer; vat: string; amount_3, unitPrice_4: integer; unit1, receiptNumber: string): integer;
begin
  commodityName := LeftStr(commodityName, C_LEN_LINE);
  vat := LeftStr(vat, 1);
  unit1 := LeftStr(unit1, 3);
  receiptNumber := LeftStr(receiptNumber, 44);
  result := _itemReturn_int( C_DEVICENUMBER,
                             rowNumber,
                             PAnsiChar(StrToAStr(commodityName)),
                             totalPrice_2,
                             PAnsiChar(StrToAStr(vat)),
                             amount_3,
                             unitPrice_4,
                             PAnsiChar(StrToAStr(unit1)),
                             PAnsiChar(StrToAStr(receiptNumber)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_itemReturn_int(%d,%d,%s,%d,%s,%d,%d,%s,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   commodityName,
                   totalPrice_2,
                   vat,
                   amount_3,
                   unitPrice_4,
                   unit1,
                   receiptNumber,
                   result]));
end;

function itemNegative_int(rowNumber: integer; commodityName: string; totalPrice_2: Integer; vat: string; amount_3, unitPrice_4: integer; unit1: string): integer;
begin
  commodityName := LeftStr(commodityName, C_LEN_LINE);
  vat := LeftStr(vat, 1);
  unit1 := LeftStr(unit1, 3);
  result := _itemNegative_int( C_DEVICENUMBER,
                               rowNumber,
                               PAnsiChar(StrToAStr(commodityName)),
                               totalPrice_2,
                               PAnsiChar(StrToAStr(vat)),
                               amount_3,
                               unitPrice_4,
                               PAnsiChar(StrToAStr(unit1)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_itemNegative_int(%d,%d,%s,%d,%s,%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   commodityName,
                   totalPrice_2,
                   vat,
                   amount_3,
                   unitPrice_4,
                   unit1,
                   result]));
end;

function itemDiscount_int(rowNumber: integer; description: string; operationType, discountValue_2: integer; vat: string): integer;
begin
  description := LeftStr(description, C_LEN_DISCOUNT);
  vat := LeftStr(vat, 1);
  result := _itemDiscount_int( C_DEVICENUMBER,
                               rowNumber,
                               PAnsiChar(StrToAStr(description)),
                               operationType,
                               discountValue_2,
                               PAnsiChar(StrToAStr(vat)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_itemDiscount_int(%d,%d,%s,%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   rowNumber,
                   description,
                   operationType,
                   discountValue_2,
                   vat,
                   result]));
end;

function printIssuedParagon(orderNumber: integer; dateTime: string): integer;
begin
  result := _printIssuedParagon( C_DEVICENUMBER, orderNumber, PAnsiChar(StrToAStr(dateTime)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printIssuedParagon(%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   orderNumber,
                   dateTime,
                   result]));
end;

procedure seRawLogginOff();
begin
  _seRawLogginOff();
  if fSettings.B['ekasa.withLog'] then
    addLog('_seRawLogginOff()');
end;

procedure setRawLogginOn(fileName: string);
begin
  _setRawLogginOn(PAnsiChar(StrToAStr(fileName)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setRawLogginOn(%s)',[fileName]));
end;

function setLocationGPS(vertX, vertY: double): integer;
begin
  result := _setLocationGPS(C_DEVICENUMBER, vertX, vertY);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setLocationGPS(%d,%10.6f,%10.6f) = %d',
                  [C_DEVICENUMBER,
                   vertX,
                   vertY,
                   result]));
end;

function setLocationAddress(municipality, street, number, subNumber, zip: string): integer;
begin
  result := _setLocationAddress( C_DEVICENUMBER,
                                 PAnsiChar(StrToAStr(municipality)),
                                 PAnsiChar(StrToAStr(street)),
                                 PAnsiChar(StrToAStr(number)),
                                 PAnsiChar(StrToAStr(subNumber)),
                                 PAnsiChar(StrToAStr(zip)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setLocationAddress(%d,%s,%s,%s,%s,%s) = %d',
                  [C_DEVICENUMBER,
                   municipality,
                   street,
                   number,
                   subNumber,
                   zip,
                   result]));
end;

function setLocationOther(description: string): integer;
begin
  result := _setLocationOther(C_DEVICENUMBER, PAnsiChar(StrToAStr(description)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setLocationOther(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   description,
                   result]));
end;

function printReport_str(reportType: string; reportNumber:integer): integer;
begin
  reportType := LeftStr(reportType, 1);
  result := _printReport_str(C_DEVICENUMBER, PAnsiChar(StrToAStr(reportType)), reportNumber);
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printReport_str(%d,%s,%d) = %d',
                  [C_DEVICENUMBER,
                   reportType,
                   reportNumber,
                   result]));
end;

function Popis0DPH_str(type1:string): integer;
begin
  result := _Popis0DPH_str(C_DEVICENUMBER, PAnsiChar(StrToAStr(type1)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_Popis0DPH_str(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   type1,
                   result]));
end;

function setTransactionID(internalCode: string): integer;
begin
  internalCode := LeftStr(internalCode, C_LEN_50);
  result := _setTransactionID(C_DEVICENUMBER, PAnsiChar(StrToAStr(internalCode)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setTransactionID(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   internalCode,
                   result]));
end;

function printJournalStructU(paragonSn: string): integer;
begin
  paragonSn := LeftStr(paragonSn, 44);
  result := _printJournalStructU(C_DEVICENUMBER, PAnsiChar(StrToAStr(paragonSn)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printJournalStructU(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   paragonSn,
                   result]));
end;

function printDisplay(displayType: integer; escSequence, text: string): integer;
begin
  text := LeftStr(text, C_LEN_LINE);
  result := _printDisplay(C_DEVICENUMBER, displayType, PAnsiChar(StrToAStr(escSequence)), PAnsiChar(StrToAStr(text)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_printDisplay(%d,%d,%s,%s) = %d',
                  [C_DEVICENUMBER,
                   displayType,
                   escSequence,
                   text,
                   result]));
end;

function clearDisplay(displayType: integer; escSequence: string): integer;
begin
  result := _clearDisplay(C_DEVICENUMBER, displayType, PAnsiChar(StrToAStr(escSequence)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_clearDisplay(%d,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   displayType,
                   escSequence,
                   result]));

end;

function setEscapeSequence(sequence: string): integer;
begin
  result := _setEscapeSequence(C_DEVICENUMBER, PAnsiChar(StrToAStr(sequence)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setEscapeSequence(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   sequence,
                   result]));
end;

function setEmail(email: string): integer;
begin
  email := LeftStr(email, 254);
  result := _setEmail(C_DEVICENUMBER, PAnsiChar(StrToAStr(email)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setEmail(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   email,
                   result]));
end;

function setSMTP(type1, ipAddress, localDir: string; port: integer): integer;
begin
  type1 := '1'; //0-SMTP, 1-Directory, 2-SMTP + Directory
  ipAddress := '0123456';
  port := 1;
  ipAddress := LeftStr(ipAddress, C_LEN_LINE);
  localDir := LeftStr(localDir, 255);
  result := _setSMTP( C_DEVICENUMBER,
                      PAnsiChar(StrToAStr(type1)),
                      PAnsiChar(StrToAStr(ipAddress)),
                      port,
                      PAnsiChar(StrToAStr(localDir)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setSMTP(%d,%s,%s,%d,%s) = %d',
                  [C_DEVICENUMBER,
                   type1,
                   ipAddress,
                   port,
                   localDir,
                   result]));
end;

function opravaDokladu(errCode: string): integer;
begin
  result := _opravaDokladu( C_DEVICENUMBER, PAnsiChar(StrToAStr(errCode)) );
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_opravaDokladu(%d,%s) = %d',
                  [C_DEVICENUMBER,
                   errCode,
                   result]));
end;

function setSellerID_str(number, type1: string): integer;
begin
  result := _setSellerID_str( C_DEVICENUMBER, PAnsiChar(StrToAStr(number)), PAnsiChar(StrToAStr(type1)));
  if fSettings.B['ekasa.withLog'] then
    addLog(Format('_setSellerID_str(%d,%s,%s) = %d',
                  [C_DEVICENUMBER,
                   number,
                   type1,
                   result]));

end;

procedure clearVats;
var
  i: integer;
begin
  for i := Low(TVats) to High(TVats) do
    vats[i] := -1;
end;

function isClearVats: boolean;
var
  i: integer;
begin
  result := true;
  for i := Low(TVats) to High(TVats) do
    if vats[i] >= 0 then begin
      result := false;
      break;
    end;
end;

function internalReadVariable(variableCode: string; onlyVariable: boolean = false): string;
var
  err: integer;
begin
  result := '';
  err := getVariable(variableCode, result);
  if (err <> 0) then exit;

  if onlyVariable then begin
    if AnsiStartsText(variableCode + C_VAR_SEP, Result) then
      System.Delete(Result, 1, Length(variableCode + C_VAR_SEP))
    else
      result := '';
  end;
end;

function internalReadStavFM: TStavBowa;
const
  CMD_STAVFM = 'F11';
var
  s: string;
  i: integer;
begin
  s := internalReadVariable(CMD_STAVFM);

  with Result do begin
    i := Pos(C_VAR_SEP, s);
    PKod:= LeftStr(s, i-1);
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavSDC:= StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavPRN := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavPC := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    CRiadku := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavS := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavF := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    VerziaF := StrToInt(s);
  end;
end;

function internalReadStavDU: TDUBowa;
const
  CMD_STAVFM = 'E81';
var
  s: string;
  dt: string;
  i: integer;
begin
  s := internalReadVariable(CMD_STAVFM);

  with Result do begin
    i := Pos(C_VAR_SEP, s);
    PKod := LeftStr(s, i-1);
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    CisloDU := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    dt := LeftStr(s, i-1);
    Insert(FormatSettings.TimeSeparator, dt, 11);
    Insert(' ', dt, 9);
    Insert(FormatSettings.DateSeparator, dt, 5);
    Insert(FormatSettings.DateSeparator, dt, 3);
    DatCasDU := dt;
    System.Delete(s, 1, i);

    i := Pos(C_VAR_SEP, s);
    StavDU := StrToInt(LeftStr(s, i-1));
    System.Delete(s, 1, i);

    dt := s;
    Insert(FormatSettings.DateSeparator, dt, 5);
    Insert(FormatSettings.DateSeparator, dt, 3);
    DatCasDS := dt;
  end;
end;

function internalReadStavCHDU(): TCHDUBowa;
const
  CMD_B11 = 'B11';
  CMD_F71 = 'F71';
var
  sl: TStringList;
begin
  sl := TStringList.Create;
  try
    sl.Clear;
    sl.LineBreak := C_VAR_SEP;
    sl.Text := InternalReadVariable(CMD_B11);
    with result do begin
      chdu := sl.Strings[1] + ' ' + sl.Strings[2];
      lastTransactionNumber := sl.Strings[3];
      storageSize := sl.Strings[7];
      sectorSize := sl.Strings[5];
    end;
    sl.Clear;
    sl.LineBreak := C_VAR_SEP;
    sl.Text := InternalReadVariable(CMD_F71);
    result.ppekk := Trim(Copy(sl.Strings[4],12,Length(sl.Strings[4])));
  finally
    sl.Free;
  end;
end;

function internalReadStavSFS(): TSFSBowa;
const
  CMD_B21 = 'B21';
  CMD_B31 = 'B31';
var
  sl: TStringList;
begin
  sl := TStringList.Create;
  try
    sl.Clear;
    sl.LineBreak := C_VAR_SEP;
    sl.Text := InternalReadVariable(CMD_B21);
    result.numberUnsentMessages := sl.Strings[1];

    sl.Clear;
    sl.Text := InternalReadVariable(CMD_B31);
    result.validitySignatureCertificate := Copy(sl.Strings[1],1,2) + '.' +
                                           Copy(sl.Strings[1],3,2) + '.' +
                                           Copy(sl.Strings[1],5,4);
  finally
    sl.Free;
  end;
end;

procedure internalReadVats();

  function readVat(variableCode: string): currency;
  var
    s: string;
    i: integer;
  begin
    result := -1;
    s := internalReadVariable(variableCode);
    i := Pos(C_VAR_SEP, s);
    if i > 0 then begin
      System.Delete(s, 1, i);
      i := Pos(C_VAR_SEP, s);
      if i > 0 then begin
        s := LeftStr(s, i - 1);
        result := DecStrToCurrDef(s, -1);
      end;
    end;
  end;

const
  CMD_DPH_A = C_VAR_12 + '1';
  CMD_DPH_B = C_VAR_12 + '2';
  CMD_DPH_C = C_VAR_12 + '3';
  CMD_DPH_D = C_VAR_12 + '4';
  CMD_DPH_E = C_VAR_12 + '5';
begin
  ClearVats;
  vats[1] := readVat(CMD_DPH_A);
  vats[2] := readVat(CMD_DPH_B);
  vats[3] := readVat(CMD_DPH_C);
  vats[4] := readVat(CMD_DPH_D);
  vats[5] := readVat(CMD_DPH_E);
end;

procedure internalReadLengthLine();
var
  sl: TStringList;
begin
  sl := TStringList.Create;
  try
    sl.Clear;
    sl.LineBreak := C_VAR_SEP;
    sl.Text := InternalReadVariable('F41');
    C_LEN_LINE := StrToIntDef(sl.Strings[3], 40);
  finally
    sl.Free;
  end;
end;

procedure internalOtvorSmenu;
var
  err: integer;
  stav: TStavBowa;
  date_s: string;
begin
  // Zjistit aktualni stav
  stav := internalReadStavFM;

  if (stav.StavS = 70) then begin
    date_s := FormatDateTime('DDMMYYYYHHNNSS',now);
    err := setDateTime(date_s);
    if (err <> 0) then exit;
  end;

  stav := InternalReadStavFM;
  if (stav.StavS = 113) or (stav.StavS = 114) then begin
    err := confirmNote();
    if (err <> 0) then exit;
  end
  else if stav.StavS >= 100 then begin
    exit;
  end
  else if stav.StavS = 0 then begin
    //TODO nastavenie platcu/neplatcu => pokial som toto nenastavil tak mi nechcel pocitat so sadzbou
    err := setParameter(0,ifThenEx(fSettings.B['ekasa.vatPayer'],0,1));
    if (err <> 0) then exit;
    // zaciatok predajneho dna/smeny
    sellingDayBegin(C_SALEMODE_FISKAL);
  end;
end;

function getReference(): string;
const
  CMD_B41 = 'B41';
var
  CPD,UID,OKP,QRKod,PKP: string;
  sl: TStringList;
begin
  sl := TStringList.Create;
  try
    sl.Clear;
    sl.LineBreak := C_VAR_SEP;
    sl.Text := internalReadVariable(CMD_B41);
    CPD := sl.Strings[1];
    UID := sl.Strings[2];
    OKP := sl.Strings[3];
    QRKod := sl.Strings[4];
    PKP := sl.Strings[5];
  finally
    sl.Free;
  end;

  result := UID;
  if result = 'null' then //Poznámka: ak nebol doklad skomunikovaný na SFS, UID je 0
    result := OKP;
end;

function getBowaDateTime(sDateTime: string): string;
begin
  result := Copy(sDateTime,9,2) + Copy(sDateTime,6,2) + Copy(sDateTime,1,4) + //DDMMYYYY
            Copy(SDateTime,12,2) + Copy(sDateTime,15,2) + Copy(sDateTime,18,2); //hhnnss
end;

procedure internalInit();
var
  err: integer;
begin
  if not bowaOpen then begin
    //spojenie s eKasou bude prebiehat cez "FM GUID CLIENT" EKasaPPEKK_x.bat
    err := openFM(fSettings.S['ekasa.hostAddress']);
    if (err <> 0) then exit;
    bowaOpen := true;
  end;
end;

procedure internalClose();
begin
  try
    closeFM();
  finally
    bowaOpen := false;
  end;
end;

function init_eKasaBowa: integer;
const
  C_LIB_NAME = 'FMInterfaceDLL.dll';
  C_VER: TFileVersion = (Build: 1; Release: 0; Minor: 19; Major: 2);
  CMD_B11 = 'B11';
  CMD_F71 = 'F71';
  CMD_B91 = 'B91';
var
  dllPath,s: string;
  sl: TStringList;
  chduVer,ppekkVer,license: integer;
begin
  result := -1;
  isEkasaInit := false;

  if (fSettings.I['ekasa.typ'] = ord(ftEBowa)) then
    if not CheckInstalledPackage(pckgBowa, true) then exit;

  if (fSettings.I['ekasa.typ'] = ord(ftEVaros)) then
    if not CheckInstalledPackage(pckgVaros, true) then exit;

  if dllHandle = 0 then begin
    {Zavedenie DLL}
    dllPath := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0))+'dll') + C_LIB_NAME;
    if not FileExists(dllPath) then begin
      lastError := Format('Súbor "%s" nebol nájdený.',[C_LIB_NAME]);
      exit;
    end;

    try
      dllHandle := LoadLibrary(PChar(dllPath));
      if dllHandle = 0 then begin
        lastError := 'Nie je možné zavies potrebnú dynamickú knižnicu!';
        exit;
      end;
      _openFM := GetProcAddress(dllHandle, 'openFM');
      _closeFM := GetProcAddress(dllHandle, 'closeFM');
      _paragonBegin := GetProcAddress(dllHandle, 'paragonBegin');
      _paragonEnd := GetProcAddress(dllHandle, 'paragonEnd');
      _itemSale_int := GetProcAddress(dllHandle, 'itemSale_int');
      _itemNegative_int := GetProcAddress(dllHandle, 'itemNegative_int');
      _itemDiscount_int := GetProcAddress(dllHandle, 'itemDiscount_int');
      _itemReturn_int := GetProcAddress(dllHandle, 'itemReturn_int');
      _sellingDayBegin := GetProcAddress(dllHandle, 'sellingDayBegin');
      _repeatParagon := GetProcAddress(dllHandle, 'repeatParagon');
      _destroyParagon := GetProcAddress(dllHandle, 'destroyParagon');
      _payment_int := GetProcAddress(dllHandle, 'payment_int');
      _printAnnouncement := GetProcAddress(dllHandle, 'printAnnouncement');
      _printAnnouncementNF := GetProcAddress(dllHandle, 'printAnnouncementNF');
      _setPreline := GetProcAddress(dllHandle, 'setPreline');
      _setPostline := GetProcAddress(dllHandle, 'setPostline');
      _printDisplay := GetProcAddress(dllHandle, 'printDisplay');
      _clearDisplay := GetProcAddress(dllHandle, 'clearDisplay');
      _setEscapeSequence := GetProcAddress(dllHandle, 'setEscapeSequence');
      _setParameter := GetProcAddress(dllHandle, 'setParameter');
      _setDateTime := GetProcAddress(dllHandle, 'setDateTime');
      _printReport_str := GetProcAddress(dllHandle, 'printReport_str');
      _getVariable := GetProcAddress(dllHandle, 'getVariable');
      _depositeInDrawer_int := GetProcAddress(dllHandle, 'depositeInDrawer_int');
      _confirmNote := GetProcAddress(dllHandle, 'confirmNote');
      _setClientID := GetProcAddress(dllHandle, 'setClientID');
      _printIssuedParagon := GetProcAddress(dllHandle, 'printIssuedParagon');
      _setInvoiceNumber := GetProcAddress(dllHandle, 'setInvoiceNumber');
      _redeemVoucher := GetProcAddress(dllHandle, 'redeemVoucher');
      _redeemVoucher_str := GetProcAddress(dllHandle, 'redeemVoucher_str');
      _getParagonIDs_str := GetProcAddress(dllHandle, 'getParagonIDs_str');
      _getParagonIDs_ResultObject := GetProcAddress(dllHandle, 'getParagonIDs_ResultObject');
      _getParagonIDs_str_ResultObject := GetProcAddress(dllHandle, 'getParagonIDs_str_ResultObject');
      _setTransactionID := GetProcAddress(dllHandle, 'setTransactionID');
      _setLocationGPS := GetProcAddress(dllHandle, 'setLocationGPS');
      _setLocationAddress := GetProcAddress(dllHandle, 'setLocationAddress');
      _setLocationOther := GetProcAddress(dllHandle, 'setLocationOther');
      _printUnsentSFSpackets := GetProcAddress(dllHandle, 'printUnsentSFSpackets');
      _sendUnsentSFSpackets := GetProcAddress(dllHandle, 'sendUnsentSFSpackets');
      _Popis0DPH_str := GetProcAddress(dllHandle, 'Popis0DPH_str');
      _printJournalStructU := GetProcAddress(dllHandle, 'printJournalStructU');
      _seRawLogginOff := GetProcAddress(dllHandle, 'seRawLogginOff');
      _setRawLogginOn := GetProcAddress(dllHandle, 'setRawLogginOn');
      _setSMTP := GetProcAddress(dllHandle, 'setSMTP');
      _setEmail := GetProcAddress(dllHandle, 'setEmail');
      _opravaDokladu := GetProcAddress(dllHandle, 'opravaDokladu');
      _setSellerID_str := GetProcAddress(dllHandle, 'setSellerID_str');
      _synchronizationToPPEKK := GetProcAddress(dllHandle, 'synchronizationToPPEKK');
      _setLicense := GetProcAddress(dllHandle, 'setLicense');
      _getLastTransactionPackets := GetProcAddress(dllHandle, 'getLastTransactionPackets');
    except
      lastError := 'Nie je možné zavies potrebnú dynamickú knižnicu!';
      exit;
    end;
  end;

  if (cashRoundSupport = -1) then begin
    internalInit();
    try
      if bowaOpen then begin
        cashRoundSupport := 0;
        sl := TStringList.Create;
        try
          //chdu
          sl.Clear;
          sl.LineBreak := C_VAR_SEP;
          sl.Text := internalReadVariable(CMD_B11);
          s := sl.Strings[2];
          s := StringReplace(s,'.','',[rfReplaceAll]);
          chduVer := StrToInt(s);
          //ppekk
          sl.Clear;
          sl.LineBreak := C_VAR_SEP;
          sl.Text := internalReadVariable(CMD_F71);
          s := UpperCase(sl.Strings[4]);
          s := StringReplace(s,'BOWA S.R.O. EKASASK1 ','',[rfReplaceAll]);
          //F71;121;21;1.4b01;BOWA s.r.o. eKasaSK1 1.4d
          //F71;122;22;1.4b01;BOWA s.r.o. eKasaSK1 1.5d
          s := DelNotNumChar(s);
          ppekkVer := StrToInt(s);
          //licenia pre zaokruhlovanie
          sl.Clear;
          sl.LineBreak := C_VAR_SEP;
          sl.Text := internalReadVariable(CMD_B91);
          s := UpperCase(sl.Strings[1]);
          license := StrToIntDef(s,0);
          //Momentalne platne kombinacie su
          //CHDU CHDUA1 1.3 - PPEKK eKasaSK1 1.4/1.5 a CHDU CHDUA1 2.3 - PPEKK eKasaSK1 2.4
          //plus musi mat aktivnu licenciu
          if ((chduVer >= 13) and (ppekkVer >= 14)) or ((chduVer >= 23) and (ppekkVer >= 24)) then begin
            cashRoundSupport := ifThenEx(license=1,1,-1);
          end;
        finally
          sl.Free;
        end;
      end;
    finally
      internalClose();
    end;
  end;

  isEkasaInit := (cashRoundSupport = 0) or (cashRoundSupport = 1);
  if isEkasaInit then result := 0;
end;

function eKasaBowaInit: boolean;
begin
  if not isEkasaInit then begin
    init_eKasaBowa;
  end;
  result := isEkasaInit;
end;

function stavStr(stav: integer): string;
begin
  case Stav of
      0: result:= rs_S0;
      1: result:= rs_S1;
      2: result:= rs_S2;
      3: result:= rs_S3;
      4: result:= rs_S4;
     10: result:= rs_S10;
     20: result:= rs_S20;
     70: result:= rs_S70;
    100: result:= rs_S100;
    101: result:= rs_S101;
    102: result:= rs_S102;
    103: result:= rs_S103;
    104: result:= rs_S104;
    105: result:= rs_S105;
    106: result:= rs_S106;
    107: result:= rs_S107;
    108: result:= rs_S108;
    109: result:= rs_S109;
    113: result:= rs_S113;
    114: result:= rs_S114;
  else
    result:= '';
  end;
end;

function errorStr(errCode: integer): string;
var
  s,addError: string;
  PPEKK_LAST_ERROR,SFS_LAST_ERROR: integer;
begin
  addError := '';
  s := internalReadVariable(C_VAR_B51);
  System.Delete(s, 1, Pos(C_VAR_SEP, s));
  PPEKK_LAST_ERROR := StrToIntDef(LeftStr(s, Pos(C_VAR_SEP, s)-1), 0);
  System.Delete(s, 1, Pos(C_VAR_SEP, s));
  System.Delete(s, 1, Pos(C_VAR_SEP, s));
  SFS_LAST_ERROR := StrToIntDef(s, 0);

  if (PPEKK_LAST_ERROR = 20) then
    addError := sfsErrorStr(SFS_LAST_ERROR)
  else
    addError := ppekkErrorStr(PPEKK_LAST_ERROR);

  case errCode of
    $20: result := rs_Err20H;
    $21: result := rs_Err21H;
    $22: result := rs_Err22H;
    $23: result := rs_Err23H;
    $24: result := rs_Err24H;
    $25: result := rs_Err25H;
    $26: result := rs_Err26H;
    $27: result := rs_Err27H;
    $28: result := rs_Err28H;
    $2A: result := rs_Err2AH;
    //
    $30: result := rs_Err30H;
    $31: result := rs_Err31H;
    $32: result := rs_Err32H;
    $33: result := rs_Err33H;
    $34: result := rs_Err34H;
    //
    $40: result := rs_Err40H;
    $41: result := rs_Err41H;
    $42: result := rs_Err42H;
    $43: result := rs_Err43H;
    //
    $50: result := rs_Err50H;
    $51: result := rs_Err51H;
    $52: result := rs_Err52H;
    $53: result := rs_Err53H;
    $54: result := rs_Err54H;
    $55: result := rs_Err55H;
    $56: result := rs_Err56H;
    $57: result := rs_Err57H;
    $58: result := rs_Err58H;
    $59: result := rs_Err59H;
    //
    $60: result := rs_Err60H;
    $61: result := rs_Err61H;
    $62: result := rs_Err62H;
    $63: result := rs_Err63H;
    $64: result := rs_Err64H;
    $65: result := rs_Err65H;
    $66: result := rs_Err66H;
    $67: result := rs_Err67H;
    $68: result := rs_Err68H;
    $69: result := rs_Err69H;
    $6A: result := rs_Err6AH;
    $6B: result := rs_Err6BH;
    $6C: result := rs_Err6CH;
    $6D: result := rs_Err6DH;
    //
    $81: result := rs_Err81H;
    $82: result := rs_Err82H;
    $83: result := rs_Err83H;
    $84: result := rs_Err84H;
    $85: result := rs_Err85H;
    //
    $90..$B5: result := Format('(%d) SFS vrátil chybu odoslanej správy:',[errCode]);
    //
    $D0: result := rs_ErrD0H;
    $D1: result := rs_ErrD1H;
    $FD: result := rs_ErrFDH;
    $FE: result := rs_ErrFEH;
  else
    result := IntToStr(errCode);
  end;
  result := result + #13 + addError;
end;

function sfsError(errCode: integer): boolean;
begin
  result := ((errCode >= 144) and (errCode <= 181));
end;

function sfsErrorStr(errCode: integer): string;
begin
  case errCode of
    -1: result := '(-1) Server FS je zaneprázdnený';
    -2: result := rs_SFS_Err_2;
    -8: result := rs_SFS_Err_8;
    -10: result := rs_SFS_Err_10;
    -12: result := rs_SFS_Err_12;
    -13: result := rs_SFS_Err_13;
    -100: result := rs_SFS_Err_100;
    -101: result := rs_SFS_Err_101;
    -102: result := rs_SFS_Err_102;
    -103: result := rs_SFS_Err_103;
    -104: result := rs_SFS_Err_104;
    -105: result := rs_SFS_Err_105;
    -106: result := rs_SFS_Err_106;
    -107: result := rs_SFS_Err_107;
    -108: result := rs_SFS_Err_108;
    -109: result := rs_SFS_Err_109;
    -110: result := rs_SFS_Err_110;
    -111: result := rs_SFS_Err_111;
    -112: result := rs_SFS_Err_112;
    -113: result := rs_SFS_Err_113;
    -114: result := rs_SFS_Err_114;
    -115: result := rs_SFS_Err_115;
    -116: result := rs_SFS_Err_116;
    -117: result := rs_SFS_Err_117;
    -118: result := rs_SFS_Err_118;
    -119: result := rs_SFS_Err_119;
    -120: result := rs_SFS_Err_120;
    -121: result := rs_SFS_Err_121;
    -122: result := rs_SFS_Err_122;
    -123: result := rs_SFS_Err_123;
    -124: result := rs_SFS_Err_124;
    -125: result := rs_SFS_Err_125;
    -126: result := rs_SFS_Err_126;
    -127: result := rs_SFS_Err_127;
    -128: result := rs_SFS_Err_128;
    -129: result := rs_SFS_Err_129;
    -130: result := rs_SFS_Err_130;
    -131: result := rs_SFS_Err_131;
    -132: result := rs_SFS_Err_132;
  end;
end;

function ppekkErrorStr(errCode: integer): string;
begin
  case errCode of
    1: result := rs_PPEKK_Err_1;
    2: result := rs_PPEKK_Err_2;
    3: result := rs_PPEKK_Err_3;
    4: result := rs_PPEKK_Err_4;
    5: result := rs_PPEKK_Err_5;
    6: result := rs_PPEKK_Err_6;
    7: result := rs_PPEKK_Err_7;
    8: result := rs_PPEKK_Err_8;
    9: result := rs_PPEKK_Err_9;
    10: result := rs_PPEKK_Err_10;
    11: result := rs_PPEKK_Err_11;
    12: result := rs_PPEKK_Err_12;
    13: result := rs_PPEKK_Err_13;
    14: result := rs_PPEKK_Err_14;
    15: result := rs_PPEKK_Err_15;
    16: result := rs_PPEKK_Err_16;
    17: result := rs_PPEKK_Err_17;
    18: result := rs_PPEKK_Err_18;
    19: result := rs_PPEKK_Err_19;
    20: result := rs_PPEKK_Err_20;
    21: result := rs_PPEKK_Err_21;
    22: result := rs_PPEKK_Err_22;
    23: result := rs_PPEKK_Err_23;
    24: result := rs_PPEKK_Err_24;
    25: result := rs_PPEKK_Err_25;
    26: result := rs_PPEKK_Err_26;
    27: result := rs_PPEKK_Err_27;
    28: result := rs_PPEKK_Err_28;
    29: result := rs_PPEKK_Err_29;
    30: result := rs_PPEKK_Err_30;
    31: result := rs_PPEKK_Err_31;
    32: result := rs_PPEKK_Err_32;
    33: result := rs_PPEKK_Err_33;
    34: result := rs_PPEKK_Err_34;
    35: result := rs_PPEKK_Err_35;
    36: result := rs_PPEKK_Err_36;
    37: result := rs_PPEKK_Err_37;
    38: result := rs_PPEKK_Err_38;
    39: result := rs_PPEKK_Err_39;
    40: result := rs_PPEKK_Err_40;
    41: result := rs_PPEKK_Err_41;
    42: result := rs_PPEKK_Err_42;
    43: result := rs_PPEKK_Err_43;
    44: result := rs_PPEKK_Err_44;
    45: result := rs_PPEKK_Err_45;
    46: result := rs_PPEKK_Err_46;
    47: result := rs_PPEKK_Err_47;
    48: result := rs_PPEKK_Err_48;
    49: result := rs_PPEKK_Err_49;
    50: result := rs_PPEKK_Err_50;
    51: result := rs_PPEKK_Err_51;
    52: result := rs_PPEKK_Err_52;
    53: result := rs_PPEKK_Err_53;
  end;
end;

procedure incRowNumber(out rowNumber: integer);
begin
  Inc(rowNumber);
  rowNumber := (rowNumber mod 10);
end;

function bowaState: string;
var
  Stav: TStavBowa;
  DU: TDUBowa;
  CHDUBowa: TCHDUBowa;
  SFSBowa: TSFSBowa;
  o: ISuperObject;
begin
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      Stav := internalReadStavFM();
      DU := internalReadStavDU();
      CHDUBowa := internalReadStavCHDU();
      SFSBowa := internalReadStavSFS();
      if isClearVats then internalReadVats();
      o := SO();
      o.S['arr[]'] := 'Status ekasy';
      o.S['arr[]'] := '=========================';
      o.S['arr[]'] := Format('stav µSD karty: %d (0=OK, 1=chybná)',[Stav.StavSDC]);
      o.S['arr[]'] := Format('stav tlaèiarne: %d (0=aktívna, 1=obsadená)',[Stav.StavPRN]);
      o.S['arr[]'] := Format('stav PC: %d (0=pripojené, 1= odpojené)',[Stav.StavPC]);
      o.S['arr[]'] := 'èíslo riadku posledného vykonaného príkazu v rámci otvorenej';
      o.S['arr[]'] := Format('úètenky: %d',[Stav.CRiadku]);
      o.S['arr[]'] := Format('stav procesu: S%d%s (S0-S4, S10, S20, S70 –procesné, >=S100 -chybové)',[Stav.StavS,' ' + stavStr(Stav.StavS)]);
      o.S['arr[]'] := Format('stav fiskalizácie: %d (1=po fiskalizácii, 0=pred fiskalizáciou/SKÚŠKA POKLADNICE)',[Stav.StavF]);
      o.S['arr[]'] := Format('verzia firmware: %d (zmeny firmware)',[Stav.VerziaF]);
      o.S['arr[]'] := '';
      o.S['arr[]'] := 'Sadzby DPH';
      o.S['arr[]'] := '=========================';
      o.S['arr[]'] := Format('A = %6.2f%%',[vats[1]]);
      o.S['arr[]'] := Format('B = %6.2f%%',[vats[2]]);
      o.S['arr[]'] := Format('C = %6.2f%%',[vats[3]]);
      o.S['arr[]'] := Format('D = %6.2f%%',[vats[4]]);
      o.S['arr[]'] := Format('E = %6.2f%%',[vats[5]]);
      o.S['arr[]'] := 'Stav dennej uzávierky';
      o.S['arr[]'] := '=========================';
      o.S['arr[]'] := Format('èíslo poslednej vykonanej DU: %d',[DU.CisloDU]);
      o.S['arr[]'] := Format('dátum a èas poslednej vykonanej DU: %s',[DU.DatCasDU]);
      o.S['arr[]'] := Format('DU v rámci dna už bola: %d (0=nevykonaná, 1=vykonaná)',[DU.StavDU]);
      o.S['arr[]'] := Format('dátum otvorenia poslednej smeny: %s',[DU.DatCasDS]);
      o.S['arr[]'] := 'Vyèítanie stavu CHDÚ a PPEKK';
      o.S['arr[]'] := '=========================';
      o.S['arr[]'] := Format('CHDÚ: %s',[CHDUBowa.chdu]);
      o.S['arr[]'] := Format('PPEKK: %s',[CHDUBowa.ppekk]);
      o.S['arr[]'] := Format('Èíslo poslednej transakcie: %s',[CHDUBowa.lastTransactionNumber]);
      o.S['arr[]'] := Format('Ve¾kos úložiska: %s',[CHDUBowa.storageSize]);
      o.S['arr[]'] := Format('Ve¾kos sektora: %s',[CHDUBowa.sectorSize]);
      o.S['arr[]'] := 'Neodoslané správy na SFS';
      o.S['arr[]'] := '=========================';
      o.S['arr[]'] := Format('Poèet neodoslaných správ na SFS: %s',[SFSBowa.numberUnsentMessages]);
      o.S['arr[]'] := Format('Platnos podpisového certifikátu SFS: %s',[SFSBowa.validitySignatureCertificate]);
      result := o['arr'].AsString;
    end
    else
      result := rs_connection_error;
  finally
    internalClose();
  end;
end;

function bowaCopyLast(): string;
var
  err: integer;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      err := repeatParagon();
      if (err <> 0) then exit;

      result := '{"message":"OK"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaCopyByUuid(): string;
const
  C_LEN_BUFF = 1024;
var
  err: integer;
  buff: array [1..C_LEN_BUFF] of AnsiChar;
  sl: TStringList;
  uuidCopy: string;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      uuidCopy := paramByName('uuid',reqParams);
      if (uuidCopy = '') then exit;

      err := _getParagonIDs_str( C_DEVICENUMBER,
                                 PAnsiChar(StrToAStr('2')),
                                 PAnsiChar(StrToAStr(uuidCopy)),
                                 @buff,
                                 C_LEN_BUFF );

      if err = 0 then begin
        sl := TStringList.Create;
        try
          sl.Clear;
          sl.LineBreak := C_VAR_SEP;
          sl.Text := AStrToStr(StrPas(PAnsiChar(@buff)));
          err := printJournalStructU(sl.Strings[2]);
        finally
          sl.Free;
        end;
      end;

      result := '{"message":"OK"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaReceipt(): string;
var
  err: integer;
  reqObj: ISuperObject;
  rowNumber: integer;
  operationType: integer;
  amount_2: integer;
  description,uidOkp: string;
  vat,s: string;
  totalPrice_2: integer;
  amount_3: integer;
  unitPrice_4: integer;
  text: string;
  bRefund,vatPayer: boolean;
  item: ISuperObject;
  commodityName: string;
  total_2,payedAmount_2: integer;

  function checkRefund: boolean;
  var
    item: ISuperObject;
  begin
    result:= false;
    for item in reqObj['ReceiptData.Items'] do begin
      if (item.C['Quantity'] < 0) then begin
        if not(isReturnType(item.S['Custom.Unit'])) then begin
          result := true;
          break;
        end;
      end
      else begin
        result := false;
        break;
      end;
    end;
  end;

  function get_vatID(vatRate: string): string;
  var
    vatRateCurr: currency;
  begin
    vatRate := ReplaceStr(vatRate,'%','');
    vatRate := ReplaceStr(vatRate,'OOD','');
    vatRate := ReplaceStr(vatRate,'PDP','');
    vatRate := ReplaceStr(vatRate,'CK','');
    vatRate := ReplaceStr(vatRate,'PT','');
    vatRate := ReplaceStr(vatRate,'UD','');
    vatRate := ReplaceStr(vatRate,'ZPS','');
    vatRate := ReplaceStr(vatRate,'INE','');
    vatRateCurr := StrToCurrDef(vatRate,0);
    result := C_VAT_A;
    if vats[1] = vatRateCurr then
      result := C_VAT_A
    else if vats[2] = vatRateCurr then
      result := C_VAT_B
    else if vats[3] = vatRateCurr then
      result := C_VAT_C
    else if vats[4] = vatRateCurr then
      result := C_VAT_D
    else if vats[5] = vatRateCurr then
      result := C_VAT_E
  end;

  function specialRegulation(taxType: string): string;
  begin
    result := '2';
    if (taxType = 'OOD') then result := '1'
    else if (taxType = 'PDP') then result := '0'
    else if (taxType = 'CK') then result := '2'
    else if (taxType = 'PT') then result := '3'
    else if (taxType = 'UD') then result := '4'
    else if (taxType = 'ZPS') then result := '5';
  end;

  function get_SellerIdType(sellerIdType: string): string;
  begin
    if (sellerIdType = 'DIC') then result := '0'
    else if (sellerIdType = 'IC_DPH') then result := '1'
    else result := '0';
  end;

begin
  err := 0;
  rowNumber := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      reqObj := SO(reqData);

      if (reqObj.S['ReceiptData.ReceiptType'] = 'PD') then begin
  //      printPosReceipt();

        bRefund := CheckRefund();
        if IsClearVats then InternalReadVats();
        if (C_LEN_LINE = 0) then internalReadLengthLine();

        err := setSMTP('1', '', fSettings.S['ekasa.mailPath'], 1);
        if (err <> 0) then exit;
        // zaciatok predajneho dna/smeny
        internalOtvorSmenu;
        vatPayer := fSettings.B['ekasa.vatPayer'];
        err := paragonBegin( rowNumber,
                             ifThenEx(vatPayer, C_SALETYPE_0, C_SALETYPE_1),
                             C_TYPPRENOSU_ROW,
                             C_PARAGONTYPE_PLUS,
                             C_TYPREKAP_SHORT,
                             fSettings.I['ekasa.headerBitmap']
                           );
        if (err <> 0) then exit;

        //Nastavenie ID interneho kodu nadradenej app (jedinecnost riesi aplikacia)
        err := setTransactionID(reqObj.S['Uuid']);
        if (err <> 0) then exit;

        //identifikacia dokladu ako paragonu
        if (reqObj.B['ReceiptData.Paragon']) then begin
          err := printIssuedParagon(StrToIntDef(reqObj.S['ReceiptData.ParagonNumber'],1),
                                    getBowaDateTime(reqObj.S['ReceiptData.IssueDate']));
          if (err <> 0) then exit;
        end;

        for item in reqObj['ReceiptData.Items'] do begin

          vat := get_vatID(item.S['VatRate']);
          amount_3 := Trunc(Zaok(item.C['Quantity'] * 1000, 0, 0));
          totalPrice_2 := Trunc(Zaok(item.C['Price'] * 100, 0, 0));
          unitPrice_4 := Trunc(Zaok(item.C['Custom.PriceUnit'] * 10000, 0, 0));

          //tlac celeho nazvu, alebo jeho orezanie na dlzku 40 znakov
          //TODO ??? otazka na tych malych prn pegassino
          commodityName := item.S['Name'];
          if (Length(commodityName) > C_LEN_LINE) then begin
            if fSettings.B['ekasa.printFullName'] then begin
              text := LeftStr(commodityName, C_LEN_LINE);
              err := setPreline(text);
              if (err <> 0) then exit;
              System.Delete(commodityName, 1, C_LEN_LINE);
            end;
            commodityName := LeftStr(commodityName, C_LEN_LINE);
          end;

          // Pokial je cenaMJ na viac ako 2DM, tak vypisat
          if (decPlCount(item.C['Custom.PriceUnit']) > 2) then begin
            description := Format(rs_JednotkovaCena, [value_x(item.C['Custom.PriceUnit'],decPlCount(item.C['Custom.PriceUnit']))]);
            err := setPostline(description);
            if (err <> 0) then exit;
          end;
(*
  KLADNÁ        K  Kladná položka – suma položky za predaj tovaru alebo poskytnutie služby
  VRATENÉOBALY  VO Záporná položka - suma položky za vykúpené zálohované obaly
  VRATENÁ       V  Záporná položka - zrušenie evidovanej položky po jej vystavení na pokladniènom doklade pri vrátení tovaru alebo služby
  OPRAVNÁ       O  Kladná alebo záporná položka - negácia položky už zaevidovaného dokladu v systéme e-kasa v prípade jej opravy
  Z¼AVA         Z  Záporná položka – suma poskytnutých zliav
*)
          {K - kladna polozka (+)
           VO - vratne obaly (-)
           V - vratenie (-)
           O - opravna (+/-)
           Z - zlava (-)
           OZ - odpocet zalohy (-)
           VP - vymennny poukaz (-)}

          if (item.S['ItemType'] = 'K') then begin
            incRowNumber(rowNumber);
            err := itemSale_int( rowNumber,
                                 commodityName,
                                 totalPrice_2,
                                 vat,
                                 amount_3,
                                 unitPrice_4,
                                 item.S['Custom.Unit'] );
            if (err <> 0) then exit;
          end

          else if (item.S['ItemType'] = 'Z') then begin
            operationType := C_ITEMDISCOUNT_SLEVAHOD;
            description := item.S['Name'];
            totalPrice_2 := Trunc(Zaok(item.C['Price'] * 100, 0, 0));
            incRowNumber(rowNumber);
            err := itemDiscount_int( rowNumber,
                                     description,
                                     operationType,
                                     totalPrice_2,
                                     vat );
            if (err <> 0) then exit;
          end

          else if MatchStr(UpperCase(item.S['ItemType']),['V','VO','O']) then begin
            amount_3 := amount_3 * -1;
            unitPrice_4 := unitPrice_4 * -1;

            if (isReturnType(item.S['Custom.Unit'])) then begin
              incRowNumber(rowNumber);
              err := itemNegative_int( rowNumber,
                                       commodityName,
                                       totalPrice_2,
                                       vat,
                                       amount_3,
                                       unitPrice_4,
                                       item.S['Custom.Unit'] );
              if (err <> 0) then exit;
            end
            else begin
              incRowNumber(rowNumber);
              err := itemReturn_int( rowNumber,
                                     commodityName,
                                     totalPrice_2,
                                     vat,
                                     amount_3,
                                     unitPrice_4,
                                     item.S['Custom.Unit'],
                                     item.S['ReferenceReceiptId'] );
              if (err <> 0) then exit;
            end;

          end;

          //priznak, ktory blizsie specifikuje priradenie dane s hodnotou 0
          if (item.S['SpecialRegulation'] <> '') then begin
            err := Popis0DPH_str(specialRegulation(item.S['SpecialRegulation']));
            if (err <> 0) then exit;
          end;

          //identifikacia predavajuceho v ktoreho mene bol predany tovar, alebo poskytnuta sluzba
          if not Empty(item.S['SellerId']) then begin
            err := setSellerID_str(item.S['SellerId'],
                                   get_SellerIdType(item.S['SellerIdType']));
            if err <> 0 then exit;
          end;

        end;

        //Zaslanie dokladu mailom
        if not Empty(reqObj.S['ReceiptData.Custom.Email']) then
          if not Empty(fSettings.S['ekasa.mailPath']) then begin
            err := setEmail(reqObj.S['ReceiptData.Custom.Email']);
            if (err <> 0) then exit;
          end;

      //PLATBY - UHRADY
      total_2 := Trunc(Zaok(reqObj.C['ReceiptData.Amount'] * 100, 0, 0)); //celkove sucty
      if bRefund then begin //pri storno/vrateni nie je povolena kombinacia platieb
        if (reqObj.C['ReceiptData.Custom.PaymentCard'] <> 0) then begin
          // Karta - storno/vratenie - posiela sa nezaokruhlena hodnota sumy dokladu celkom
          payedAmount_2 := Trunc(Zaok(reqObj.C['ReceiptData.Custom.PaymentCard'] * 100, 0, 0));
          description := rs_PAYMENTTYPE_KARTA;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_KARTA,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
          if (err <> 0) then exit;
        end
        else begin
          // Hotovost - storno/vratenie - posiela sa zaokruhlena hodnota sumy dokladu celkom na 5 centy
          // v tomto pripade ju uz tak mam zaokruhlenu v dmAgendy.mdtKasaPLATENE.AsCurrency
          payedAmount_2 := Trunc(Zaok(reqObj.C['ReceiptData.Custom.PaymentCash']-reqObj.C['ReceiptData.Custom.CashReturn'] * 100, 0, 0));
          description := rs_PAYMENTTYPE_HOTOV;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_HOTOV,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
          if (err <> 0) then exit;
        end;
      end
      else begin
        // Sek - nesmie sa preplacat
        payedAmount_2 := Trunc(Zaok(reqObj.C['ReceiptData.Custom.PaymentCheck'] * 100, 0, 0));
        if (total_2 > 0) and (payedAmount_2 > 0) then begin // protoze na sek nelze vracet, testujeme total_2 na > 0
          description := rs_PAYMENTTYPE_SEK;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_SEK,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
        if (err <> 0) then exit;
          if (total_2 > 0) and (payedAmount_2 > total_2) then
            payedAmount_2 := total_2;
          total_2 := total_2 - payedAmount_2
        end;
        // Karta - moze sa preplacat
        payedAmount_2 := Trunc(Zaok(reqObj.C['ReceiptData.Custom.PaymentCard'] * 100, 0, 0));
        if (total_2 <> 0) and (payedAmount_2 <> 0) then begin
          description := rs_PAYMENTTYPE_KARTA;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_KARTA,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
        if (err <> 0) then exit;
          if (total_2 > 0) and (payedAmount_2 > total_2) then
            payedAmount_2 := total_2;
          total_2 := total_2 - payedAmount_2
        end;
        // Uver - nesmie sa preplacat
        payedAmount_2 := Trunc(Zaok(reqObj.C['ReceiptData.Custom.PaymentOther'] * 100, 0, 0));
        if (total_2 > 0) and (payedAmount_2 > total_2) then
          payedAmount_2 := total_2;
        if (total_2 > 0) and (payedAmount_2 > 0) then begin // protoze na uver nelze vracet, testujeme total_2 na > 0
          description := rs_PAYMENTTYPE_UVER;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_UVER,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
          if (err <> 0) then exit;
          total_2 := total_2 - payedAmount_2
        end;
        // Hotovost - moze sa preplacat
        payedAmount_2 := Trunc(Zaok((reqObj.C['ReceiptData.Custom.PaymentCash']-reqObj.C['ReceiptData.Custom.CashReturn']) * 100, 0, 0));
        if (total_2 <> 0) and ((payedAmount_2 <> 0) or (reqObj.C['ReceiptData.Custom.CashReturn'] <> 0)) then begin
          description := rs_PAYMENTTYPE_HOTOV;
          incRowNumber(rowNumber);
          err := payment_int( rowNumber,
                              C_PAYMENTTYPE_HOTOV,
                              total_2,
                              payedAmount_2,
                              0,
                              description );
          if (err <> 0) then exit;
        end;
      end;
(*
      // tlac potvrdenia z POS
      // 1. => pouziva sa POS a bola platba kartou
      if ((CardPOS.EPType = eptCSOB_ECR2) and
          (CardPOS.EPTypStvrzenky in [ord(tsBoth),ord(tsCustomer)]) and
          (dmFm.tblHlvPLATKAR.AsCurrency <> 0)) then
        // 2. => POS netlaci potvrdenku a mame nejake data pre tlac potvrdenku
        if ((CardPOS.EPTerminalTisk = false) and (CardPOS.CardPOSTransaction.IsEmpty = false)) then begin
          incRowNumber(rowNumber);
          err := printAnnouncement(rowNumber, ' ');
          if (err <> 0) then exit;
          incRowNumber(rowNumber);
          err := printAnnouncement(rowNumber, 'Potvrdenka pre zákazníka');
          if (err <> 0) then exit;
          incRowNumber(rowNumber);
          err := printAnnouncement(rowNumber, '------------------------');
          if (err <> 0) then exit;

          sl := TStringList.Create;
          try
            sl.LineBreak := #$D#$A;
            sl.Text := CardPOS.CardPOSTransaction.PrintedText(true, tsCustomer);
            for i := 0 to sl.Count - 1 do begin
              incRowNumber(rowNumber);
              err := printAnnouncement(rowNumber, sl.Strings[i]);
              if (err <> 0) then exit;
            end;
          finally
            sl.Free;
          end;
          incRowNumber(rowNumber);
          err := printAnnouncement(rowNumber, ' ');
          if (err <> 0) then exit;
        end;
*)
        // ukoncit paragon
        incRowNumber(rowNumber);
        err := paragonEnd(rowNumber, fSettings.I['ekasa.footerBitmap']);
        if (err <> 0) then exit;

        uidOkp := getReference();
        result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                         '"uid":"%s"}',[uidOkp,uidOkp]);

        if sfsError(err) then
          result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                           '"uid":"%s",'+
                           '"messageAdd":"%s"}',[uidOkp,uidOkp,sfsErrorStr(err)]);

      end;

      if (reqObj.S['ReceiptData.ReceiptType'] = 'UF') then begin
        if isClearVats then internalReadVats();
        if (C_LEN_LINE = 0) then internalReadLengthLine();

        err := setSMTP('1', '', fSettings.S['ekasa.mailPath'], 1);
        if (err <> 0) then exit;
        // zaciatok predajneho dna/smeny
        internalOtvorSmenu;
        err := paragonBegin( rowNumber
                            ,C_SALETYPE_9
                            ,C_TYPPRENOSU_ROW
                            ,C_PARAGONTYPE_PLUS
                            ,C_TYPREKAP_SHORT
                            ,C_GRAPHICSHDR_NO
                           );
        if (err <> 0) then exit;

        //Nastavenie ID interneho kodu nadradenej app (jedinecnost riesi aplikacia)
        err := setTransactionID(reqObj.S['Uuid']);
        if (err <> 0) then exit;

        //identifikacia dokladu ako paragonu
        if (reqObj.B['ReceiptData.Paragon']) then begin
          err := printIssuedParagon(StrToIntDef(reqObj.S['ReceiptData.ParagonNumber'],1),
                                    getBowaDateTime(reqObj.S['ReceiptData.IssueDate']));
          if (err <> 0) then exit;
        end;

        vat:= C_VAT_A; // Faktura ma tabulkovy index A
        totalPrice_2 := Trunc(Zaok(reqObj.C['ReceiptData.Amount'] * 100, 0, 0));
        amount_3 := Trunc(Zaok(1 * 1000, 0, 0));
        unitPrice_4 := Trunc(Zaok(Abs(reqObj.C['ReceiptData.Amount']) * 10000, 0, 0));
        s := LeftStr(rs_Uhrada + reqObj.S['ReceiptData.InvoiceNumber'], C_LEN_LINE);
        //
        incRowNumber(rowNumber);
        if (reqObj.C['ReceiptData.Amount'] < 0) then begin
          totalPrice_2 := totalPrice_2 * -1;
          err := itemReturn_int( rowNumber, s, totalPrice_2, vat, amount_3, unitPrice_4, '', '');
          if (err <> 0) then exit;
        end
        else begin
          err := itemSale_int( rowNumber, s, totalPrice_2, vat, amount_3, unitPrice_4, '');
          if (err <> 0) then exit;
        end;

        err := setInvoiceNumber(reqObj.S['ReceiptData.InvoiceNumber']);
        if (err <> 0) then exit;

        //Zaslanie dokladu mailom
        if not Empty(reqObj.S['ReceiptData.Custom.Email']) then
          if not Empty(fSettings.S['ekasa.mailPath']) then begin
            err := setEmail(reqObj.S['ReceiptData.Custom.Email']);
            if (err <> 0) then exit;
          end;

        // Vypada to, ze u faktury se na celkove soucty nehraje
         if (reqObj.C['ReceiptData.Custom.PaymentCard'] <> 0) then begin //kartou
          incRowNumber(rowNumber);
          err := payment_int( rowNumber, C_PAYMENTTYPE_KARTA, 0, 0, 0, rs_PAYMENTTYPE_KARTA );
          if (err <> 0) then exit;

        end;
         if (reqObj.C['ReceiptData.Custom.PaymentCash'] <> 0) then begin  //hotovost
          incRowNumber(rowNumber);
          err := payment_int( rowNumber, C_PAYMENTTYPE_HOTOV, 0, 0, 0, rs_PAYMENTTYPE_HOTOV );
          if (err <> 0) then exit;
        end;

        // vytlaci meno a ucel
        if not Empty(reqObj.S['ReceiptData.Custom.Cashier']) then begin
          text := 'Meno: ' + reqObj.S['ReceiptData.Custom.Cashier'];
          incRowNumber(rowNumber);
          err := printAnnouncementNF(rowNumber, text);
          if (err <> 0) then exit;
        end;

        if not Empty(reqObj.S['ReceiptData.Custom.Purpose']) then begin
          text := 'Úèel: ' + reqObj.S['ReceiptData.Custom.Purpose'];
          incRowNumber(rowNumber);
          err := printAnnouncementNF(rowNumber, text);
          if (err <> 0) then exit;
        end;

        // ukoncit paragon
        incRowNumber(rowNumber);
        err := paragonEnd(rowNumber, C_GRAPHICSHDR_NO);
        if (err <> 0) then exit;

        uidOkp := getReference();
        result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                         '"uid":"%s"}',[uidOkp,uidOkp]);

        if sfsError(err) then
          result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                           '"uid":"%s",'+
                           '"messageAdd":"%s"}',[uidOkp,uidOkp,sfsErrorStr(err)]);
      end;

      if (reqObj.S['ReceiptData.ReceiptType'] = 'VK') then begin
        operationType:= C_DEPOSITEINDRAWER_VKLAD;
        description:= rs_VkladHot;
        if (C_LEN_LINE = 0) then internalReadLengthLine();
        // zaciatok predajneho dna/smeny
        internalOtvorSmenu;
        err := paragonBegin( rowNumber,
                             C_SALETYPE_5,
                             C_TYPPRENOSU_ROW,
                             C_PARAGONTYPE_PLUS,
                             C_TYPREKAP_ALL,
                             C_GRAPHICSHDR_NO );
        if (err <> 0) then exit;

        incRowNumber(rowNumber);
        amount_2 := Trunc(Zaok(Abs(reqObj.C['ReceiptData.Amount']) * 100, 0, 0));
        err := depositeInDrawer_int( rowNumber,
                                     description,
                                     operationType,
                                     amount_2,
                                     C_PAYMENTTYPE_HOTOV );
        if (err <> 0) then exit;

        // ukoncit paragon
        incRowNumber(rowNumber);
        err := paragonEnd(rowNumber, C_GRAPHICSHDR_NO);
        if (err <> 0) then exit;

        uidOkp := getReference();
        result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                         '"uid":"%s"}',[uidOkp,uidOkp]);

        if sfsError(err) then
          result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                           '"uid":"%s",'+
                           '"messageAdd":"%s"}',[uidOkp,uidOkp,sfsErrorStr(err)]);
      end;

      if (reqObj.S['ReceiptData.ReceiptType'] = 'VY') then begin
        operationType:= C_DEPOSITEINDRAWER_VYBER;
        description:= rs_VybHot;
        if (C_LEN_LINE = 0) then internalReadLengthLine();
        // zaciatok predajneho dna/smeny
        internalOtvorSmenu;
        err := paragonBegin( rowNumber,
                             C_SALETYPE_5,
                             C_TYPPRENOSU_ROW,
                             C_PARAGONTYPE_PLUS,
                             C_TYPREKAP_ALL,
                             C_GRAPHICSHDR_NO );
        if (err <> 0) then exit;

        incRowNumber(rowNumber);
        amount_2 := Trunc(Zaok(Abs(reqObj.C['ReceiptData.Amount']) * 100, 0, 0));
        err := depositeInDrawer_int( rowNumber,
                                     description,
                                     operationType,
                                     amount_2,
                                     C_PAYMENTTYPE_HOTOV );
        if (err <> 0) then exit;

        // ukoncit paragon
        incRowNumber(rowNumber);
        err := paragonEnd(rowNumber, C_GRAPHICSHDR_NO);
        if (err <> 0) then exit;

        uidOkp := getReference();
        result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                         '"uid":"%s"}',[uidOkp,uidOkp]);

        if sfsError(err) then
          result := Format('{"message":"Doklad UID:%s úspešne zaevidovaný a odoslaný do tlaèiarne.",'+
                           '"uid":"%s",'+
                           '"messageAdd":"%s"}',[uidOkp,uidOkp,sfsErrorStr(err)]);
      end;

    end;
  finally
    if (err <> 0) then begin
      result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
      incRowNumber(rowNumber);
      destroyParagon(rowNumber, 'destroyParagon');
    end;
    internalClose();
  end;
end;

function bowaLocationGps(): string;
var
  err: integer;
  reqObj: ISuperObject;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      reqObj := SO(reqData);
      err := setLocationGPS(reqObj.D['Gps.AxisX'], reqObj.D['Gps.AxisY']);
      if (err <> 0) then exit;

      result := '{"message":"Poloha úspešne zaevidovaná"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaLocationAddress(): string;
var
  err: integer;
  reqObj: ISuperObject;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      reqObj := SO(reqData);
        err := setLocationAddress(reqObj.S['PhysicalAddress.Municipality'],
                                  reqObj.S['PhysicalAddress.StreetName'],
                                  reqObj.S['PhysicalAddress.PropertyRegistrationNumber'],
                                  reqObj.S['PhysicalAddress.BuildingNumber'],
                                  reqObj.S['PhysicalAddress.PostalCode']);
      if (err <> 0) then exit;

      result := '{"message":"Poloha úspešne zaevidovaná"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaLocationOther(): string;
var
  err: integer;
  reqObj: ISuperObject;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      reqObj := SO(reqData);
      err := setLocationOther(reqObj.S['Other']);
      if (err <> 0) then exit;

      result := '{"message":"Poloha úspešne zaevidovaná"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaProReport(): string;
var
  err: integer;
  report: string;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      report := paramByName('type',reqParams);
      if (Lowercase(report) = 'zreport') then begin
        err := printReport_str('Z', 1);
        if (err <> 0) then exit;
      end
      else if (Lowercase(report) = 'xreport') then begin
        err := printReport_str('X', 1);
      if (err <> 0) then exit;
      end
      else begin
        result := '{"errorCode":500,"error":"unsupported request"}';
        exit;
      end;

      result := '{"message":"OK"}'
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaUnsent(): string;
var
  err: integer;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      err := printUnsentSFSpackets();
      if (err <> 0) then exit;

      result := '{"message":"OK"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaSendunsent(): string;
var
  err: integer;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      err := sendUnsentSFSpackets();
      if (err <> 0) then exit;

      result := '{"message":"Odosielanie neodoslaných dátových správ na server eKASA FS spustené"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function TxtEsc2BowaEsc(sEsc: string): string;
var
  Esc: string;
  EscBin: AnsiString;
  i: integer;
begin
  result := '';
  if TxtToBin(sEsc, Esc) then begin
    EscBin := StrToAStr(Esc);
    for i := 1 to Length(EscBin) do
      result := result + C_ESC_CHAR + IntToHex(Ord(EscBin[i]), 2);
  end;
end;

function internalEscapeSequence(EscSeq: string; ErrMsg: string = ''): integer;
begin
  if Pos(C_ESC_CHAR, EscSeq) = 0 then
    EscSeq := TxtEsc2BowaEsc(EscSeq);
  result := setEscapeSequence(EscSeq);
end;

function bowaPrncdkick(): string;
const
  C_DRAWER1_OPEN = '~1B~70~00~20~80';
  C_DRAWER2_OPEN = '~1B~70~01~20~80';
var
  err: integer;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      case fSettings.I['ekasa.drawer'] of
        0: err := internalEscapeSequence(C_DRAWER1_OPEN);
        1: err := internalEscapeSequence(C_DRAWER2_OPEN)
      end;
      if (err <> 0) then exit;

      result := '{"message":"Odosielanie neodoslaných dátových správ na server eKASA FS spustené"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function bowaSenderror(): string;
var
  err: integer;
begin
  err := 0;
  result := '';
  internalInit();
  try
    if (bowaOpen) then begin
      err := opravaDokladu(FormatDateTime('DDMMYYYYhhnnss',Now));
      if (err <> 0) then exit;

      result := '{"message":"OK"}';
    end;
  finally
    if (err <> 0) then result := Format('{"errorCode":500,"errorEkasa":%d,"error":"%s"}',[err,errorStr(err)]);
    internalClose();
  end;
end;

function eKasaBowaWork(action: TEkasaActions): string;
begin
  result := '';
  case action of
    actState: result := bowaState;
    actSettingsGet: result := '{"errorCode":500,"error":"unsupported request"}';
    actSettingsPost: result := '{"errorCode":500,"error":"unsupported request"}';
    actCopyLast: result := bowaCopyLast;
    actCopyByUuid: result := bowaCopyByUuid;
    actCopyById: result := '{"errorCode":500,"error":"unsupported request"}';
    actReceipt: result := bowaReceipt;
    actReceiptStateId: result := '{"errorCode":500,"error":"unsupported request"}';
    actLocationGps: result := bowaLocationGps;
    actLocationAddress: result := bowaLocationAddress;
    actLocationOther: result := bowaLocationOther;
    actReport: result := bowaProReport;
    actUnsent: result := bowaUnsent;
    actSendunsent: result := bowaSendunsent;
    actPrncdkick: result := bowaPrncdkick;
    actPrnfreeprint: result := '{"errorCode":500,"error":"unsupported request"}';
    actSenderror: result := bowaSenderror;
    actExamplereceipt: result := '{"errorCode":500,"error":"unsupported request"}';
    actSelectpayments: result := '{"errorCode":500,"error":"unsupported request"}';
  end;
end;

initialization
  clearVats();

end.
